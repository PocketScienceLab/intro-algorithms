% !TEX encoding = ISO-8859-1
\chapter{Algoritmos de Dispersão (Hash)}
\label{dispersao}
\index{dispersao@dispersão}
\index{dispersao@dispersão!algoritmos de}
\index{hash}

Este capítulo apresenta uma técnica simples e eficiente de
implementação de dicionários que ilustra bem o compromisso entre tempo
e espaço no projeto de implementação de algoritmos e estruturas de
dados. O uso de mais espaço pode diminuir o tempo e o uso de menos
espaço pode aumentar o tempo de execução, mas há sempre um limite
superior para a quantidade de espaço a ser utilizada.

\index{dicionario@dicionário} Em computação, um dicionário é um tipo
abstrato que define operações de inserção, remoção e pesquisa.

Os dados são usualmente organizados em registros com diversos campos,
dentre eles um ou mais campos que são usados como {\em chave\/} para a
pesquisa, inserção ou remoção.

\index{função de dispersão} \index{índice de dispersão} Algoritmos de
dispersão (em inglês, {\em hashing\/}) se baseiam na ideia simples de
distribuir os dados em um vetor de certo tamanho --- que vamos chamar
de tabela de dispersão --- usando uma {\em função de dispersão\/}, que
associa um índice do vetor a cada chave.

\index{\disperse} Por exemplo, se a chave é um inteiro positivo ou
nulo e a tabela de dispersão tem tamanho $m$, a função de dispersão
pode ser a função $\disperse$ tal que $\disperse(v) = v \% m$, onde
$\%$ é a função que calcula o resto da divisão de números inteiros.

% Se a chave for um caractere, a função de dispersão $\disperse$ pode
% ser tal que $\delta(v) = \ord(v) \% m$, onde $\ord$ é a função que
% associa a cada caractere o código inteiro que o
% representa. Computadores usam um código para representar cada
% caractere; hoje em dia usualmente Unicode ou uma variação do código
% Unicode, antigamente usava-se código Ascii.

\index{compromisso entre tempo e espaço} A distribuição dos valores a
serem pesquisados em uma tabela é um bom exemplo do compromisso entre
tempo e espaço, fundamental no projeto de algoritmos. Se não houver
limitação de memória, poderia ser definido um tamanho de vetor
bastante grande de modo que um único índice fosse associado a cada
valor. Se não houver limitação de tempo, o projeto poderia não usar
dispersão (i.e.~considerar vetor de tamanho nulo) e usar algoritmos
sequenciais em uma lista. Na prática, deve-se procurar determinar um
tamanho que não gaste espaço de memória de mais e nem de menos, para a
tabela de dispersão. Há algoritmos que dinamicamente alteram
(tipicamente, dobram) o tamanho da tabela, quando o {\em fator de
  ocupação\/} --- número de elementos existentes dividido pelo tamanho
(número de índices) da tabela --- alcança um valor pré-estabelecido
(em geral, igual ou pouco maior que 0,5).  \index{fator de ocupação!de
  tabela de dispersão}

\index{colisão!em algoritmos de dispersão} Uma {\em colisão\/} ocorre
quando a função de dispersão retorna o mesmo índice para duas ou mais
chaves. Colisões devem ocorrer raramente se o tamanho da tabela de
dispersão é grande e uma boa função de dispersão é usada. Mas um
mecanismo de tratamento de colisões é em geral necessário em todo
algoritmo de dispersão, devido à possibilidade de ocorrência de
colisões.

A dispersão de valores se baseia no fato de que é mais eficiente
procurar um valor em um subconjunto de todos os valores, i.e.~o
subconjunto dos valores para os quais a função de dispersão fornece o
mesmo resultado. A pesquisa usando dispersão é o método conhecido mais
poderoso e o mais usado para pesquisa de dados. A maioria dos sistemas
de recuperação de dados usados atualmente são baseados em dispersão.

\index{tratamento de colisões!em algoritmos de dispersão!aberto}
\index{tratamento de colisões!em algoritmos de dispersão!fechado} Há
duas versões de tratamento de colisões em algoritmos de dispersão:
{\em aberto\/} e {\em fechado}.

\index{tratamento de colisões!em algoritmos de dispersão!aberto}
\index{encadeamento separado}
No tratamento aberto, também chamado de tratamento de colisão por {\em
  encadeamento separado\/} (em inglês, {\em separate chaining\/}), a
tabela de dispersão é uma tabela de apontadores para lista de
elementos para os quais houve colisão.

\index{endereçamento aberto}
\index{sondagem linear}
\index{tratamento de colisões!em algoritmos de dispersão!fechado}
No tratamento fechado, também chamado de {\em endereçamento aberto\/}
(em inglês, {\em open addressing\/}), todas as chaves são armazenadas
na própria tabela (o que implica que o tamanho da tabela é maior que o
número de chaves inseridas). Diferentes estratégias podem ser usadas
para resolução de conflitos, mas a mais simples --- chamada de {\em
  sondagem linear\/} (em inglês, {\em linear probing\/}) --- usa a
primeira posição, seguinte à que ocorreu a colisão, que está vazia
(considerando a tabela como circular, isto é, a primeira posição da
tabela segue a última). Embora pesquisa e inserção sejam relativamente
simples de implementar segundo a técnica de sondagem linear, a remoção
de chaves é mais complicada. Em geral, é usado um símbolo
especialmente reservado para indicar que uma chave foi removida da
posição. Não vamos abordar o tratamento fechado de colisões.

\section{Inserção, pesquisa e remoção de elementos de tabela de dispersão com encadeamento separado}
\label{Ops-dicionario-hash-aberto}

Basicamente, as operações usam uma função de dispersão \disperse\ e
operações em uma lista sequencial, como mostrado a seguir, onde
\ina{ins}, \ina{pesq} e \ina{remov} são funções para inserção,
pesquisa e remoção em lista sequencial de valores e supomos que
  \begin{enumerate}
     \item \ina{tabDisp} é um arranjo de ponteiros, de tipo
       \ina{TabDisp}, onde os elementos são ponteiros para valores de
       tipo \ina{Dados},

     \item \ina{\disperse} é uma função que retorna um índice
       (inteiro) de \ina{tabDisp} ao receber uma chave, e 

     \item a chave é campo de nome \ina{chave} de \ina{Dados}.
  \end{enumerate}

\begin{center}
\begin{tabular}{l}
\begin{alg}{tabDisp_ins, tabDisp_pesq, tabDisp_remov}{\definicao}
TabDisp tabDisp_ins (e, t) = ins(e, t[disperse(e -> chave)])

Dados tabDisp_pesq (chave, t) = pesq(chave, t[disperse(chave)])

TabDisp tabDisp_remov (e, t) = remov(e, t[disperse(e -> chave)])
\end{alg}
\end{tabular}
\end{center}

Funções em Haskell para criação de tabelas de dispersão com tamanho
especificado como parâmetro, e algoritmos simples para inserção,
pesquisa e remoção de elementos na tabela de dispersão criada são
apresentados a seguir.

As funções usam código monádico, na mônada \inh{IO}, devido ao uso dos
chamados arranjos {\em mutáveis\/}, isto é, arranjos cujo conteúdo
pode ser modificado (em vez de ser criado novo arranjo que difere do
original apenas por uma operação de modificar um valor contido no
arranjo).

\begin{center}
\begin{tabular}{l}
\begin{hask}{insere,novaTabDisp,remove,pesquisa}{\definicao}
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-- Implementação de algoritmo simples de dispersão de valores. 
-----------------------------------------------------------------------
module Dispersão (TabDisp, novaTabDisp, insere, remove, pesquisa) where

import Prelude 
import Data.Maybe        (Maybe)
import Data.IORef        (IORef, newIORef, readIORef, writeIORef)
import Data.Array.MArray (getBounds, newArray, readArray, writeArray)
import Data.Array.IO     (IOArray)
import Data.Hashable     (Hashable, hash)

-----------------------------------------------------------------------
type Indice            = Int
type TabDisp chave val = IOArray Int [(chave,val)]

-- Chaves podem ter o mesmo índice (valor de dispersão), portanto a 
-- tabela armazena além do valor a lista de chaves com mesmo índice.

-- ------------------------------------------------------------
novaTabDisp :: Int -> IO (TabDisp chave val) 
novaTabDisp tam = newArray (0,tam-1) []

-- -----------------------------------------------------------------------------
insere :: Hashable chave => TabDisp chave val -> chave -> val -> IO ()
-- Insere (chave,val) na cabeça da lista de chaves com mesmo índice na tabela.  
insere tab chave val = atualizaTab ((chave,val):) tab chave

--------------------------------------------------------------------------------
obtemLista :: Hashable chave => TabDisp chave val -> chave -> IO [(chave,val)]
obtemLista tab chave = do 
   (_,n) <- getBounds tab
   lista <- readArray tab (hash chave)
   return lista

atualizaTab :: Hashable chave => ([(chave,val)] -> [(chave,val)]) -> 
               TabDisp chave val -> chave -> IO ()
atualizaTab funObtemLista tab chave = do
  lista <- obtemLista tab chave
  (_,n) <- getBounds tab
  writeArray tab (hash chave) (funObtemLista lista)

-- -----------------------------------------------------------------------------
remAll :: Hashable chave => (chave -> Bool) -> [(chave,val)] -> [(chave, val)]
-- Remove chave de lista.
remAll _     []             = []
remAll eq_k0 (par@(k0,_):x) =
  case remAll eq_k0 x of
    x' | eq_k0 k0  -> x'
       | otherwise -> par:x'

remove :: (Eq chave, Hashable chave) => TabDisp chave val -> chave -> IO ()
remove tab chave = atualizaTab (remAll (==chave)) tab chave

-- -----------------------------------------------------------------------------
-- Retorna valor correspondente a chave na tabela de dispersão.
pesquisa :: (Eq chave,Hashable chave)=>TabDisp chave val->chave->IO (Maybe val)
pesquisa tab chave = do
  lista <- obtemLista tab chave
  let primVal (k,v) r | chave == k  = Just v
                      | otherwise   = r
  return (foldr primVal Nothing lista)

-- -----------------------------------------------------------------------------
\end{hask}
\end{tabular}
\end{center}
