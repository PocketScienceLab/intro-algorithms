%!TEX encoding = ISO-8859-1
\section{Árvores}
\label{sec:arvores}
\index{arvores}

Uma árvore é um {\em grafo} conexo e acíclico. 

\HRule
{\em Nota\/}: 

Um {\em grafo\/} é um conjunto de vértices e de arestas, cada aresta
conectando dois vértices. Dois vértices $a$ e $b$ de um grafo são
chamados {\em adjacentes\/} se estão conectados por uma aresta --
usualmente representada como um par $(a,b)$. Um grafo é {\em conexo\/}
se todo vérice é adjacente a algum outro. Um {\em caminho\/} de um
vértice $a$ a um vértice $b$ é uma sequência de vértices adjacentes,
tendo $a$ como primeiro e $b$ como último vértice. Um {\em ciclo\/} é
um caminho que inicia e termina no mesmo vértice, não repetindo
nenhuma aresta. Um grafo é {\em acíclico\/} se não contém nenhum
ciclo. Um grafo acíclico, mas não for conexo, é uma floresta, isto é,
um conjunto de árvores.

\HRule

No entanto, vamos considerar neste livro apenas (o que é chamado de)
{\em árvore com raiz\/} (em inglês, {\em rooted tree\/}), e ver essa
estrutura de dados como sendo recursiva, definida de modo a ser ou i)
vazia (uma folha) ou ii) um nodo contendo um elemento e um certo
número de ramos (ou nodos), que contêm sub-árvores. Em Haskell,
podemos definir:

\begin{center}
\begin{tabular}{l}
\begin{hask}{Tree,Leaf,Node}
data Tree a = Leaf | Node a [Tree a]
\end{hask}
\end{tabular}
\end{center}

Na definição acima, o construtor \inh{Leaf} constrói uma árvore vazia,
ou folha, e o construtor \inh{Node} constrói uma árvore contendo um
valor de tipo \inh{a} e um lista de subárvores.

Outra possível definição considera que a informação é armazenada nas
folhas, em vez de nos nodos internos:

\begin{center}
\begin{tabular}{l}
\begin{hask}{Tree,Leaf,Node}
data Tree' a = Leaf' a | Node' [Tree' a]
\end{hask}
\end{tabular}
\end{center}

Uma árvore com exatamente duas sub-árvores (possivelmente vazias) é
chamada de árvore binária e pode ser definida como:

\begin{center}
\begin{tabular}{l}
\begin{hask}{BTree,BLeaf,BNode}
 data BTree a = BLeaf | BNode a (BTree a) (BTree a)
\end{hask}
\end{tabular}
\end{center}

Em linguagens que provêem suporte ao uso de ponteiros, mas não à
definição e manipulação direta de tipos recursivos, a representação de
árvores binárias pode ser feita com o uso de ponteiro como mostra o
exemplo a seguir:

\begin{center}
\begin{tabular}{l}
\begin{alg}{ArvoreBinariaDeInteiros}
struct ArvoreBinariaDeInteiros
     int elem
     struct ArvoreBinariaDeInteiros *esq, dir 
\end{alg}
\end{tabular}
\end{center}

Os campos \ina{esq} e \ina{dir} de um nodo são ponteiros, possivelmente nulos,
para sub-árvores.

Para árvores não binárias, pode ser usada a seguinte representação, que
podemos chamar de {\em representação com primogênito-irmão-e-pai}:

\begin{center}
\begin{tabular}{l}
\begin{alg}{ArvoreDeInteiros}
struct ArvoreDeInteiros
   int elem;
   struct ArvoreDeInteiros *primogenito, irmao, pai 
\end{alg}
\end{tabular}
\end{center}

A representação da árvore da Figura \ref{fig:Arv1} é mostrada na Figura \ref{fig:Rep-arv1}.

\begin{figure}

xxxx
\label{fig:Arv1}
\caption{Árvore exemplo}
\end{figure}

\begin{figure}

yyyyy
\label{fig:Rep-arv1}
\caption{Representação da árvore exemplo por valor do tipo \ina{ArvoreDeInteiros}}
\end{figure}
