%!TEX encoding = ISO-8859-1
\section{Árvores}
\label{sec:arvores}
\index{Árvores}

Uma árvore é um {\em grafo} conexo e acíclico. 

\HRule
{\em Nota\/}: 

Um {\em grafo\/} é um conjunto de vértices e de arestas, cada aresta
conectando dois vértices. Dois vértices $a$ e $b$ de um grafo são
chamados {\em adjacentes\/} se estão conectados por uma aresta --
usualmente representada como um par $(a,b)$. Um grafo é {\em conexo\/}
se todo vérice é adjacente a algum outro. Um {\em caminho\/} de um
vértice $a$ a um vértice $b$ é uma sequência de vértices adjacentes,
tendo $a$ como primeiro e $b$ como último vértice. Um {\em ciclo\/} é
um caminho que inicia e termina no mesmo vértice, não repetindo
nenhuma aresta. Um grafo é {\em acíclico\/} se não contém nenhum
ciclo. Um grafo acíclico, mas não for conexo, é uma floresta, isto é,
um conjunto de árvores.

\HRule

No entanto, essa definição é baseada no conceito de grafo, que não é
abordado neste livro. 

Além disso, e mais importante: vamos considerar apenas o que podemos
chamar de {\em árvore com raiz identificada\/} (em inglês, {\em rooted
  tree\/}. O adjetivo {\em identificada\/} procura evitar estranheza,
ao pensar em o que seria uma árvore sem raiz. Uma árvore com raiz
identificada pode ser definida recursivamente: é ou i) vazia (uma
folha) ou ii) um nodo contendo um elemento e um certo número de ramos
(ou nodos), que contêm sub-árvores. Em Haskell, podemos definir:

\begin{center}
\begin{tabular}{l}
\begin{hask}{Arvore,Folha,Nodo}{White}
data Arvore a = Folha | Nodo a [Arvore a]
\end{hask}
\end{tabular}
\end{center}

Na definição acima, o construtor \inh{Folha} constrói uma árvore
vazia, ou folha, e o construtor \inh{Nodo} constrói uma árvore
contendo um valor de tipo \inh{a} e um lista de subárvores.

Outra possível definição considera que a informação é armazenada nas
folhas, em vez de nos nodos internos:

\begin{center}
\begin{tabular}{l}
\begin{hask}{Avore,Folha,Nodo}{White}
data Arvore' a = Folha' a | Nodo' [Arvore' a]
\end{hask}
\end{tabular}
\end{center}

Uma árvore com exatamente duas sub-árvores (possivelmente vazias) é
chamada de árvore binária e pode ser definida como:

\begin{center}
\begin{tabular}{l}
\begin{hask}{ArvB,FolhaB,NodoB}{White}
 data ArvB a = FolhaB | NodoB a (ArvB a) (ArvB a)
\end{hask}
\end{tabular}
\end{center}

Em linguagens que provêem suporte ao uso de ponteiros, mas não à
definição e manipulação direta de tipos recursivos, a representação de
árvores binárias pode ser feita com o uso de ponteiro como mostra o
exemplo a seguir:

\begin{center}
\begin{tabular}{l}
\begin{alg}{ArvoreBinariaDeInteiros}{White}
struct ArvoreBinariaDeInteiros
     int elem
     struct ArvoreBinariaDeInteiros *esq, dir 
\end{alg}
\end{tabular}
\end{center}

Os campos \ina{esq} e \ina{dir} de um nodo são ponteiros, possivelmente nulos,
para sub-árvores.

Para árvores não binárias, pode ser usada a seguinte representação, que
podemos chamar de {\em representação com primogênito-irmão-e-pai}:

\begin{center}
\begin{tabular}{l}
\begin{alg}{ArvoreDeInteiros}{White}
struct ArvoreDeInteiros
   int elem;
   struct ArvoreDeInteiros *primogenito, irmao, pai 
\end{alg}
\end{tabular}
\end{center}

%A representação da árvore:

%xxxx

%é mostrada abaixo:

%yyyyy

