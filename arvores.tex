%!TEX encoding = ISO-8859-1
\section{Árvores}
\label{sec:arvores}
\index{arvores}

Uma árvore pode ser vista como uma estrutura de dados recursiva, definida como sendo ou i) vazia (uma folha) ou ii) um nodo contendo um elemento e um certo número de ramos (ou nodos), que contêm sub-árvores:

\begin{center}
\begin{tabular}{l}
\begin{hask}{Tree,Leaf,Node}
data Tree a = Leaf | Node a [Tree a]
\end{hask}
\end{tabular}
\end{center}

Na definição acima, o construtor \inh{Leaf} constrói uma árvore vazia, ou folha, e o construtor \inh{Node} constrói uma árvore contendo uma informação de tipo \inh{a} e um lista de subárvores.

Outra possível definição considera que a informação é armazenada nas folhas, em vez de nos nodos internos:

\begin{center}
\begin{tabular}{l}
\begin{hask}{Tree,Leaf,Node}
data Tree' a = Leaf' a | Node' [Tree' a]
\end{hask}
\end{tabular}
\end{center}

Uma árvore com exatamente duas sub-árvores (possivelmente vazias) é chamada de árvore binária e pode ser definida como:

\begin{center}
\begin{tabular}{l}
\begin{hask}{BTree,BLeaf,BNode}
 data BTree a = BLeaf a | BNode (BTree a) (BTree a)
\end{hask}
\end{tabular}
\end{center}

%---- acho que esse parágrafo deve ser eliminado
%---- é prematuro falar em grafo e nem é apresentado um desenho
%---- talvez isso possa ser deixado como nota
%
%Uma árvore pode também ser definida como um {\em grafo} conexo e  acíclico. Um {\em grafo\/} é simplesmente um conjunto de vértices e de arestas entre esses vértices. Dizemos que dois vértices $a$ e $b$ do grafo são {\em adjacentes\/} se estão conectados por uma aresta -- usualmente representada como um par$(a,b)$. Um grafo é {\em conexo\/} se todo vérice é adjacente a algum outro. Um {\em caminho\/} de um vértice $a$ a um vértice $b$ é uma sequência de vértices adjacentes, tendo $a$ como primeiro e $b$ como último vértice. Um {\em ciclo\/} é um caminho que inicia e termina no mesmo vértice, não repetindo nenhuma aresta. Um grafo é {\em acíclico\/} se não contém nenhum ciclo. Um grafo acíclico, mas não for conexo, é uma floresta, isto é, um conjunto de árvores.
%
%-----------------------------------------------------------

Em linguagens que provêem suporte ao uso de ponteiros, mas não à
definição e manipulação direta de tipos recursivos, a representação de
árvores binárias pode ser feita com o uso de ponteiro como mostra o
exemplo a seguir:

\begin{center}
\begin{tabular}{l}
\begin{alg}{ArvoreBinariaDeInteiros}
struct ArvoreBinariaDeInteiros
     int elem
     struct ArvoreBinariaDeInteiros *esq, dir 
\end{alg}
\end{tabular}
\end{center}

Os campos \ina{esq} e \ina{dir} de um nodo são ponteiros, possivelmente nulos,
para sub-árvores.

Para árvores não binárias, pode ser usada a seguinte representação, que
podemos chamar de {\em representação com primogênito-irmão-e-pai}:

\begin{center}
\begin{tabular}{l}
\begin{alg}{ArvoreDeInteiros}
struct ArvoreDeInteiros
   int elem;
   struct ArvoreDeInteiros *primogenito, irmao, pai 
\end{alg}
\end{tabular}
\end{center}

A representação da árvore da Figura \ref{fig:Arv1} é mostrada na Figura \ref{fig:Rep-arv1}.

\begin{figure}

xxxx
\caption{Árvore exemplo}
\label{fig:Arv1}
\end{figure}

\begin{figure}

yyyyy
\caption{Representação da árvore exemplo por valor do tipo \ina{ArvoreDeInteiros}}
\label{fig:Rep-arv1}
\end{figure}
\end{document}