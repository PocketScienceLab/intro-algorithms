% !TEX encoding = ISO-8859-1
\chapter{Algoritmos e Árvores de Pesquisa}
\label{algoritmos-de-pesquisa}

Pesquisar em computação significa encontrar um dado valor, chamado de
{\em chave da pesquisa\/}, dentre vários valores existentes. Os
valores existentes podem estar representados de várias formas, mas
vamos tratar neste livro apenas de listas e árvores.  Mesmo nos
restringindo apenas a essas formas de representação de valores,
existem vários algoritmos de pesquisa. 

Na seção \ref{sec:pesquisa-em-lista} apresentamos um algoritmo simples
de {\em pesquisa sequencial\/} em listas (incluindo representação com
arranjos). Duas variações simples dessa pesquisa sequencial são
apresentadas nos exercícios resolvidos. A primeira é baseada em
pesquisa em lista ordenada, que termina a pesquisa sequencial quando a
chave da pesquisa é encontrada ou quando se torna maior do que um
elemento da lista (supondo ordem crescente dos valores na lista). A
segunda usa o que é chamado de {\em sentinela} --- um elemento
adicionado ao extremo (tipicamente, de arranjo), para evitar teste
para verificar chegada a esse extremo (por isso, é usada somente
quando o número de elementos que pode ser armazenado é limitado, como
ocorre no caso de arranjos).

A seção \ref{sec:pesquisa-binaria} apresenta o eficiente algoritmo de
pesquisa em um arranjo ordenado chamada de {\em pesquisa binária}.  A
seção \ref{sec:arvore-binaria-de-pesquisa} apresenta algoritmos de
pesquisa em árvore binária, incluindo variações do algoritmo básico
(em árvores não balanceadas) para diferentes formas de obter
balanceamento da árvore na qual a pesquisa é feita, com o objetivo de
aumentar a eficiência da pesquisa.

\input{pesquisa-binaria}
\input{arvore-binaria-de-pesquisa}
\input{arvore-AVL}
\input{arvore-bicolor}
\input{arvore-B}

\section{Exercícios Resolvidos}

\begin{enumerate}

\item Escreva função que implementa algoritmo de pesquisa em lista
  ordenada.  Ou seja, escreva função que recebe um valor e uma lista,
  que pode-se supor que está ordenada, em ordem não-decrescente, e
  retorne valor booleano que indica se o valor está presente ou não na
  lista. A pesquisa deve considerar, por questão de eficiência, que a
  lista está ordenada.

{\bf Solução}: 

{\bf Versão funcional}:

\begin{center}
\begin{tabular}{l}
\begin{hask}{elemOrdL}{\decremento}
elemOrdL :: Ord a => a -> [a] -> Bool
elemOrdL _ [] = False
elemOrdL a (b:x) 
  | a < b     = elemOrdL a x
  | otherwise = a == b
\end{hask}
\end{tabular}
\end{center}

{\bf Versão imperativa}:

\begin{center}
\begin{tabular}{l}
\begin{alg}{elemOrdL}{\decremento}
elemOrdL (a, l) 
   while ((l != NULL) && (l->elem < a)) l = l->r
   return (l->elem == a)
\end{alg}
\end{tabular}
\end{center}

\item \label{ex:lista-duplamente-encadeada} ....

\item \label{ex:dicionario} Em computação, um dicionário é um tipo
  abstrato que define operações de inserção, remoção e
  pesquisa. Define um tipo abstrato dicionário usando uma árvore
  binária de pesquisa para implementação das operações sobre o tipo
  abstrato.

  {\bf Solução}: ....

\item \label{ex:arvores-MovPraRaiz} Operações em uma árvore MovPraRaiz
  (em inglês, chamada de {\em splay tree\/}), como inserção, remoção
  ou pesquisa, podem ser seguidas por uma operação básica chamada de
  {\em movPraRaiz\/}, que reorganiza a árvore de modo a mover um
  elemento para a raiz (em operações de inserção e pesquisa, o
  elemento inserido ou pesquisado; em operação de remoção, o elemento
  a ser removido é movido para a raiz antes de ser removido).  A ideia
  básica por trás disso é tornar os elementos usados mais recentemente
  próximos à raiz da árvore e a árvore razoavelmente balanceada.

  A operação \ina{movPraRaiz}, que move um nodo $x$ para a raiz, pode
  realizar um dentre os seguintes passos:
 
  \begin{enumerate}

    \item passo x-raiz: se $x$ é filho da raiz,

    \item passo x-pai-de-x-no-mesmo-lado: 
          $x$ é filho do lado esquerdo e o pai de $x$ está à esquerda da raiz, ou 
          $x$ é filho do lado direito  e o pai de $x$ está à direita da raiz, 

    \item passo x-pai-de-x-em-lados-opostos: 
          $x$ é filho do lado esquerdo e o pai de $x$ está à direita da raiz, ou 
          $x$ é filho do lado direito  e o pai de $x$ está à esquerda da raiz.

  \end{enumerate}

Essas três possibilidades são ilustradas abaixo.

...

\end{enumerate}

\section{Exercícios}

\begin{enumerate}

\item \label{remocao-de-elemento-em-arvore-binaria-de-pesquisa}
  Escreva um programa para remoção de um elemento em uma árvore
  binária de pesquisa que use comandos de repetição em vez de funções
  definidas recursivamente.

\item \label{experimente-alg-ins-arv-AVL} Escreva um programa para
  percorrer e imprimir árvores resultantes de inserções repetidas de
  elementos em uma árvore vazia, usando versão imperativa e/ou
  funcional do algoritmo de inserção em árvore AVL.

\item \label{experimente-alg-rem-arv-AVL} Escreva um programa para
  percorrer e imprimir árvores resultantes de inserções repetidas com
  remoções de alguns elementos inseridos, em uma árvore vazia, usando
  versão imperativa e/ou funcional dos algoritmos de inserção e
  remoção em árvore AVL.

\end{enumerate}
