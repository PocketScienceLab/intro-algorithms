% !TEX encoding = ISO-8859-1
\chapter{Algoritmos e Árvores de Pesquisa}
\label{algoritmos-de-pesquisa}

\index{algoritmos!de pesquisa}
\index{pesquisa}
\index{chave!de pesquisa}
Pesquisar em computação significa encontrar um dado valor, chamado de
{\em chave da pesquisa\/}, dentre vários valores existentes. Os
valores existentes podem estar representados de várias formas, mas
vamos tratar neste livro apenas de listas e árvores.  Mesmo nos
restringindo apenas a essas formas de representação de valores,
existem vários algoritmos de pesquisa. 


\index{pesquisa!sequencial} Na seção \ref{sec:pesquisa-em-lista}
apresentamos um algoritmo simples de {\em pesquisa sequencial\/} em
listas (incluindo representação com arranjos). Duas variações simples
dessa pesquisa sequencial são apresentadas nos exercícios
resolvidos. A primeira é baseada em pesquisa em lista ordenada, que
termina a pesquisa sequencial quando a chave da pesquisa é encontrada
ou quando se torna maior do que um elemento da lista (supondo ordem
crescente dos valores na lista). A segunda usa o que é chamado de {\em
  sentinela} \index{sentinela} --- um elemento adicionado ao extremo
(tipicamente, de arranjo), para evitar teste para verificar chegada a
esse extremo (por isso, é usada somente quando o número de elementos
que pode ser armazenado é limitado, como ocorre no caso de arranjos).

\index{pesquisa!binária}
\index{árvore!binária}
A seção \ref{sec:pesquisa-binaria} apresenta o eficiente algoritmo de
pesquisa em um arranjo ordenado chamada de {\em pesquisa binária}.  A
seção \ref{sec:arvore-binaria-de-pesquisa} apresenta algoritmos de
pesquisa em árvore binária, incluindo variações do algoritmo básico
(em árvores não balanceadas) para diferentes formas de obter
balanceamento da árvore na qual a pesquisa é feita, com o objetivo de
aumentar a eficiência da pesquisa.

\input{pesquisa-binaria}
\input{arvore-binaria-de-pesquisa}
\input{arvore-AVL}
\input{arvore-bicolor}
\input{arvore-B}

\section{Exercícios Resolvidos}

\begin{enumerate}

\item \label{pesquisa-sequencial-em-lista-ordenada}
  \index{pesquisa!sequencial em lista ordenada} Escreva função que
  implementa algoritmo de pesquisa em lista ordenada.  Ou seja,
  escreva função que recebe um valor e uma lista, que pode-se supor
  que está ordenada, em ordem não-decrescente, e retorne valor
  booleano que indica se o valor está presente ou não na lista. A
  pesquisa deve considerar que a lista está ordenada.

  Escreva fórmula que indique a complexidade de tempo de execução do
  algoritmo e justifique.

{\bf Solução}: 

{\bf Versão funcional}:

\begin{center}
\begin{tabular}{l}
\begin{hask}{elemOrdL}{\decremento}
elemOrdL :: Ord a => a -> [a] -> Bool
elemOrdL _ [] = False
elemOrdL a (b:x) 
  | a < b     = elemOrdL a x
  | otherwise = a == b
\end{hask}
\end{tabular}
\end{center}

{\bf Versão imperativa}:

\begin{center}
\begin{tabular}{l}
\begin{alg}{elemOrdL}{\decremento}
elemOrdL (a, l) 
   while ((l != NULL) && (l->elem < a)) l = l->r
   return (l->elem == a)
\end{alg}
\end{tabular}
\end{center}

A complexidade de tempo é a mesma da complexidade em pesquisa
sequencial em lista não ordenada: em uma lista de $n$ elementos a
complexidade é $O(n)$ no pior caso, pois envolve possivelmente
comparação com cada elemento da lista. No entanto, no caso médio a
complexidade é menor, dividida por um fator igual a $k$ --- isto é,
$T(n) \asymp O(n/k) \asymp O(n)$ ---, onde $k$ o número de elementos
da lista menores que a chave da pesquisa.

\item \label{ex:lista-duplamente-encadeada} \index{lista!duplamente
  encadeada} Uma lista duplamente encadeada ....

%\item \label{ex:dicionario} Em computação, um dicionário é um tipo
%  abstrato que define operações de inserção, remoção e
%  pesquisa. Defina um tipo abstrato dicionário usando uma árvore
%  binária de pesquisa para implementação das operações sobre o tipo
%  abstrato.
%
%  {\bf Solução}: ....

\item \label{ex:arvores-MovPraRaiz} Operações em uma árvore MovPraRaiz
  (em inglês, chamada de {\em splay tree\/}), como inserção, remoção
  ou pesquisa, podem ser seguidas por uma operação básica chamada de
  {\em movPraRaiz\/}, que reorganiza a árvore de modo a mover um
  elemento para a raiz (em operações de inserção e pesquisa, o
  elemento inserido ou pesquisado; em operação de remoção, o elemento
  a ser removido é movido para a raiz antes de ser removido).  A ideia
  básica por trás disso é tornar os elementos usados mais recentemente
  próximos à raiz da árvore e a árvore razoavelmente balanceada.

  A operação \ina{movPraRaiz}, que move um nodo $x$ para a raiz, pode
  realizar um dentre os seguintes passos:
 
  \begin{enumerate}

    \item passo x-raiz: se $x$ é filho da raiz,

    \item passo x-pai-de-x-no-mesmo-lado: 
          $x$ é filho do lado esquerdo e o pai de $x$ está à esquerda da raiz, ou 
          $x$ é filho do lado direito  e o pai de $x$ está à direita da raiz, 

    \item passo x-pai-de-x-em-lados-opostos: 
          $x$ é filho do lado esquerdo e o pai de $x$ está à direita da raiz, ou 
          $x$ é filho do lado direito  e o pai de $x$ está à esquerda da raiz.

  \end{enumerate}

Essas três possibilidades são ilustradas abaixo.

...

\end{enumerate}

\section{Exercícios}

\begin{enumerate}

\item \label{ex:remocao-de-elemento-em-arvore-binaria-de-pesquisa}
  Escreva programa para remoção de um elemento em uma árvore binária
  de pesquisa que use comandos de repetição em vez de funções
  definidas recursivamente.

\item \label{ex:alg-ins-arv-AVL} Escreva programa para percorrer e
  imprimir árvores resultantes de inserções de elementos em árvore,
  usando versão imperativa e/ou funcional do algoritmo de inserção em
  árvore AVL.  

\item \label{ex:alg-rem-arv-AVL} Escreva programa para percorrer e
  imprimir árvores resultantes de inserções repetidas com remoções de
  alguns elementos inseridos em uma árvore, usando versão imperativa
  e/ou funcional dos algoritmos de inserção e remoção em árvore AVL.

  Mostre a complexidade de tempo de execução do algoritmo de remoção
  de elemento de árvore AVL.

\item \label{ex:pesquisa-por-interpolacao} \index{pesquisa!por
  interpolação} A pesquisa por interpolação é bastante similar à
  pesquisa binária, e como esta deve ser feita também em um arranjo
  ordenado. Em vez de comparar a chave da pesquisa com o valor que
  está no meio da faixa do arranjo que está sendo pesquisada, a
  pesquisa usa o valor da chave, para determinar a posição do arranjo
  que contém o valor que vai ser comparado com a chave: sendo a faixa
  do arranjo que está sendo pesquisada do índice $e$ ao índice $r$
  (i.e.~de {\tt $A$[$e$] até $A$[$d$]}), o algoritmo considera que os
  valores no arranjo crescem linearmente com o crescimento dos
  índices.

  O algoritmo se comporta como uma pessoa procura um nome em uma lista
  telefônica. Ao procurar por um nome que começa com a letra B a
  pesquisa é dirigida a uma posição mais próxima do início da lista,
  ao passo que se o nome começa com a letra T a pesquisa é dirigida a
  uma posição mais próxima do fim da lista.
  
  \begin{enumerate}

    \item Modifique os algoritmos de pesquisa binária, cujas versões
      funcional e imperativa foram apresentadas respectivamente nas
      seções \ref{sec:pesquisa-binaria-fun} e
      \ref{sec:pesquisa-binaria-imp}, para que implementem o algoritmo
      de pesquisa por interpolação.

    \item Documente como você fez para calcular o índice do arranjo
      que é comparado com a chave (considerando crescimento linear dos
      valores no arranjo).

    \item Explique porque o pior caso do algoritmo de pesquisa por
    interpolação é pior do que no caso do algoritmo de pesquisa
    binária.

  \end{enumerate}

\end{enumerate}
