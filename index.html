<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="generator" content="hevea 2.00">
<style type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding 0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding0 tr td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
.myclisting{font-family:monospace;white-space:pre;margin:lex;padding:2ex;}
body{background-color:white}
a:link{color:#00A3B2;text-decoration:underline;}
a:visited{color:#005D66;text-decoration:underline;}
a:hover{color:black;text-decoration:none;background-color:#99F6FF}
.title{padding:1ex;background-color:#00A3B2}
.titlemain{padding:1ex;background-color:#00A3B2}
.titlerest{padding:1ex;background-color:#00A3B2}
.part{padding:1ex;background-color:#00BBCC}
.section{padding:.5ex;background-color:#66F2FF}
.subsection{padding:0.3ex;background-color:#7FF4FF}
.subsubsection{padding:0.5ex;background-color:#99F6FF}
.paragraph{padding:0.5ex;background-color:#CCFAFF}
.chapter{padding:0.5ex;background-color:#2DD6E5}
.fmarginpar{border:solid thin #7FF4FF; width:20%; text-align:left}
.ffootnoterule{border:none;margin:1em auto 1em 0px;width:50%;background-color:#00BBCC}
.ftoc1{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #00BBCC}
.ftoc2{list-style:none;margin:1ex 1ex;padding:0ex 1ex;border-left:1ex solid #2DD6E5}
.ftoc3{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #66F2FF}
.ftoc4{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #7FF4FF}
.ftoc5{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #99F6FF}
.ftoc6{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #CCFAFF}
</style>
<title> Introdução a Algoritmos 

</title>
</head>
<body >
<!--HEVEA command line is: hevea livro index -->
<!--CUT STYLE book--><!--HTMLHEAD-->
<span style="font-variant:small-caps"><span style="font-weight:bold"><span style="font-size:small">Introdução a Algoritmos</span></span></span>:<!--ENDHTML-->
<!--CUT DEF chapter 1 --><table class="title"><tr><td><h1 class="titlemain"><span style="font-variant:small-caps"> </span><span style="font-variant:small-caps">Introdução a Algoritmos</span><br>
</h1><h3 class="titlerest">Carlos Camarão<br>
<span style="font-size:small">Universidade Federal de Minas Gerais</span><br>
<span style="font-size:small">Doutor em Ciência da Computação pela Universidade de Manchester, Inglaterra</span><br>
<span style="font-size:small">©</span><span style="font-size:small"> 2015</span> </h3></td></tr>
</table><p>É permitida a duplicação ou reprodução, no todo ou em parte, sob
quaisquer formas ou por quaisquer meios (eletrônico, mecânico,
gravação, fotocópia, distribuição na Web ou outros), desde que seja
para fins não comerciais.</p><!--TOC chapter id=sec1 Conteúdo-->
<h1 id="sec1" class="chapter">Conteúdo</h1><!--SEC END --><ul class="ftoc1"><li class="li-toc">
<a href="#sec2">Prefácio</a>
<ul class="ftoc2">
<ul class="ftoc3"><li class="li-toc">
<a href="#sec3">Conteúdo e Organização do Livro</a>
</li><li class="li-toc"><a href="#sec4">Recursos Adicionais</a>
</li><li class="li-toc"><a href="#sec5">Pré-requisitos</a>
</li></ul>
</ul>
</li><li class="li-toc"><a href="#sec6">Capítulo 1  Estruturas de Dados Básicas</a>
<ul class="ftoc2"><li class="li-toc">
<a href="#sec7">1.1  Listas</a>
<ul class="ftoc3"><li class="li-toc">
<a href="#sec8">1.1.1  Pesquisa</a>
<ul class="ftoc4"><li class="li-toc">
<a href="#sec9">1.1.1.1  Versão funcional</a>
</li><li class="li-toc"><a href="#sec10">1.1.1.2  Versão imperativa</a>
</li></ul>
</li><li class="li-toc"><a href="#sec11">1.1.2  Inserção</a>
<ul class="ftoc4"><li class="li-toc">
<a href="#sec12">1.1.2.1  Versão funcional</a>
</li><li class="li-toc"><a href="#sec13">1.1.2.2  Versão imperativa</a>
</li></ul>
</li><li class="li-toc"><a href="#sec14">1.1.3  Remoção</a>
<ul class="ftoc4"><li class="li-toc">
<a href="#sec15">1.1.3.1  Versão funcional</a>
</li><li class="li-toc"><a href="#sec16">1.1.3.2  Versão imperativa</a>
</li></ul>
</li><li class="li-toc"><a href="#sec17">1.1.4  Lista duplamente encadeada</a>
</li><li class="li-toc"><a href="#sec18">1.1.5  Pilha</a>
<ul class="ftoc4"><li class="li-toc">
<a href="#sec19">1.1.5.1  Versão funcional</a>
</li><li class="li-toc"><a href="#sec20">1.1.5.2  Versão imperativa</a>
</li></ul>
</li><li class="li-toc"><a href="#sec21">1.1.6  Fila</a>
<ul class="ftoc4"><li class="li-toc">
<a href="#sec22">1.1.6.1  Versão funcional</a>
</li><li class="li-toc"><a href="#sec23">1.1.6.2  Versão imperativa</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec24">1.2  Árvores</a>
</li></ul>
</li></ul>
<!--TOC chapter id=sec2 Prefácio-->
<h1 id="sec2" class="chapter">Prefácio</h1><!--SEC END --><p>Este livro provê uma introdução ao estudo de algoritmos. Ele apresenta
estruturas de dados básicas e algoritmos de pesquisa e ordenação, e
provê uma introdução ao importante ramo da ciência da computação que
trata do desenvolvimento e análise da eficiência de algoritmos. O
assunto da análise de eficiência é comumente chamado em computação de
complexidade.</p><p>Essa análise aborda em geral quanto tempo é gasto na execução de um
algoritmo em função do tamanho da entrada: diz-se complexidade de
tempo do algoritmo. Além do tempo, pode ser analisada também a
complexidade de espaço (quanto espaço de memória é gasto na execução
em função do tamanho da entrada).</p><p>... notação ...</p><p>... funcional ...</p><p>... clareza, concisão ...</p>
<!--TOC subsection id=sec3 Conteúdo e Organização do Livro-->
<h3 id="sec3" class="subsection">Conteúdo e Organização do Livro</h3><!--SEC END -->
<!--TOC subsection id=sec4 Recursos Adicionais-->
<h3 id="sec4" class="subsection">Recursos Adicionais</h3><!--SEC END -->
<!--TOC subsection id=sec5 Pré-requisitos-->
<h3 id="sec5" class="subsection">Pré-requisitos</h3><!--SEC END --><p>Os pré-requsitos são:</p><ol class="enumerate" type=1><li class="li-enumerate">Experiência inicial com provas por indução. (??)</li></ol>
<!--TOC chapter id=sec6 Estruturas de Dados Básicas-->
<h1 id="sec6" class="chapter">Capítulo 1  Estruturas de Dados Básicas</h1><!--SEC END --><p>
<a id="estruturas-de-dados-basicas"></a></p><p>Este capítulo aborda listas e árvores, suas representações em um computador e
operações básicas sobre essas estruturas de dados.</p>
<!--TOC section id=sec7 Listas-->
<h2 id="sec7" class="section">1.1  Listas</h2><!--SEC END --><p>
<a id="sec-listas"></a></p><p>Uma lista é uma estrutura de dados comumente usada em computação e pode ser definida recursivamente como a seguir. Uma lista de elementos de
determinado tipo <code><span style="color:blue">t</span></code> é ou i) <em>vazia</em> ou ii) constituída de um elemento de tipo <code><span style="color:blue">t</span></code> e um uma lista de elementos do mesmo tipo <code><span style="color:blue">t</span></code> (denominada <em>cauda</em> ou resto da lista).</p><p>Em uma linguagem como Haskell, que provê suporte à definição de tipos
de dados recursivos, o tipo lista pode ser definido como:</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-weight:bold"><span style="color:black">data</span></span> <span style="color:#007F00">List</span> <span style="color:blue">a</span> = <span style="color:#007F00">Nil</span> | <span style="color:#007F00">Cons</span> <span style="color:blue">a</span> (<span style="color:#007F00">List</span> <span style="color:blue">a</span>)</td></tr>
</table></td></tr>
</table>
</div><p>O tipo de dado <code><span style="color:blue">List</span></code><code> </code><code><span style="color:blue">a</span></code> é um tipo recursivo, sendo <code><span style="color:blue">Nil</span></code> e <code><span style="color:blue">Cons</span></code> os construtores de valores desse tipo. Além disso, <code><span style="color:blue">List</span></code><code> </code><code><span style="color:blue">a</span></code> é um tipo <em>polimórfico</em>: a variável de tipo <code><span style="color:blue">a</span></code> pode ser instanciada para um tipo <code><span style="color:blue">t</span></code> qualquer, permitindo assim a definição de listas com elementos de desse tipo <code><span style="color:blue">t</span></code>. Por exemplo, <code>(</code><code><span style="color:blue">Cons</span></code><code> 1 (</code><code><span style="color:blue">Cons</span></code><code> 2 (</code><code><span style="color:blue">Cons</span></code><code> 3 </code><code><span style="color:blue">Nil</span></code><code>)))</code> é uma lista de tipo <code><span style="color:blue">List</span></code><code> </code><code><span style="font-weight:bold"><span style="color:black">Int</span></span></code> e <code>(</code><code><span style="color:blue">Cons</span></code><code> </code><code><span style="font-weight:bold"><span style="color:black">True</span></span></code><code> (</code><code><span style="color:blue">Cons</span></code><code> </code><code><span style="font-weight:bold"><span style="color:black">False</span></span></code><code> </code><code><span style="color:blue">Nil</span></code><code>))</code> tem tipo <code><span style="color:blue">List</span></code><code> </code><code><span style="font-weight:bold"><span style="color:black">Bool</span></span></code>. </p><p>A linguagem Haskell provê uma notação especial para a criação de valores de tipo lista: <code>[]</code> é usado em lugar de <code><span style="color:blue">Nil</span></code>, e o construtor infixado <code>(:)</code>, associativo à direita, em lugar de <code><span style="color:blue">Cons</span></code>. Por exemplo, a lista <code><span style="color:blue">Cons</span></code><code> 1 (</code><code><span style="color:blue">Cons</span></code><code> 2 (</code><code><span style="color:blue">Cons</span></code><code> 3 </code><code><span style="color:blue">Nil</span></code><code>))</code> seria representada como <code>(1:2:3:[])</code>. 
Além disso, uma lista pode ser representada simplesmente escrevendo-se os seus elementos da lista entre colchetes, separados por vírgulas. Ou seja, a lista <code>\</code><code><span style="color:blue">inh</span></code><code>{(1:2:3:[]}</code> pode ser escrita, mais simplesmente, como <code>[1,2,3]</code>. </p><p>Em linguagens como <span style="font-family:monospace">C</span>, uma lista pode ser representada por meio de <em>registros</em> (também chamados de "estruturas", em <span style="font-family:monospace">C</span>) e <em>ponteiros</em> (ou apontadores), tal como ilustrado no exemplo a seguir, que define uma lista de elementos de tipo <code><span style="font-weight:bold"><span style="color:black">int</span></span></code>. Linguagens como <span style="font-family:monospace">C</span>, que não provêm suporte para polimorfismo, requerem a definição de tipos lista distintos para cada tipo particular de elementos. </p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="color:#007F00">ListaDeInteiros</span>
   <span style="font-weight:bold"><span style="color:black">int</span></span> <span style="color:blue">elem</span>;
   <span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="color:#007F00">ListaDeInteiros</span> *<span style="color:blue">r</span>;</td></tr>
</table></td></tr>
</table>
</div><p>Uma definição de registro, em <span style="font-family:monospace">C</span>, é introduzida pela palavra-chave <code><span style="font-weight:bold"><span style="color:black">struct</span></span></code>, seguida do nome do registro &#X2013; neste caso, <code><span style="color:blue">ListaDeInteiros</span></code>. O registro possui dois campos: um campo de tipo <code><span style="font-weight:bold"><span style="color:black">int</span></span></code> e nome <code><span style="color:blue">elem</span></code>, e um campo de nome <code><span style="color:blue">r</span></code>, que é um ponteiro para valores do próprio tipo <code><span style="color:blue">ListaDeInteiros</span></code>. </p><p>A manipulação de valores de tipo lista em <span style="font-family:monospace">C</span> é bem mais trabalhosa. A falta de suporte para definição e uso de tipos recursivos e polimórficos torna a programação mais difícil e demorada e o código menos legível e mais sujeito a repetições e a ocorrências de erros. Por exemplo, para criar um valor de tipo <code><span style="color:blue">ListaDeInteiros</span></code>, com os elementos <code>1,2,3</code>, é necessário código como o seguinte:
<a id="hevea_default0"></a></p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="color:#007F00">ListaDeInteiros</span> *<span style="color:blue">p</span> =
   <span style="color:blue">malloc</span>(<span style="font-weight:bold"><span style="color:black">sizeof</span></span>(<span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="color:#007F00">ListaDeInteiros</span>))
   <span style="color:blue">p</span>-&gt;<span style="color:blue">elem</span> = 1;       <span style="color:blue">p</span>-&gt;<span style="color:blue">r</span> = <span style="color:blue">malloc</span>(<span style="font-weight:bold"><span style="color:black">sizeof</span></span>(<span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="color:#007F00">ListaDeInteiros</span>))
   <span style="color:blue">p</span>-&gt;<span style="color:blue">r</span>-&gt;<span style="color:blue">elem</span> = 2;    <span style="color:blue">p</span>-&gt;<span style="color:blue">r</span>-&gt;<span style="color:blue">r</span> = <span style="color:blue">malloc</span>(<span style="font-weight:bold"><span style="color:black">sizeof</span></span>(<span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="color:#007F00">ListaDeInteiros</span>))
   <span style="color:blue">p</span>-&gt;<span style="color:blue">r</span>-&gt;<span style="color:blue">r</span>-&gt;<span style="color:blue">elem</span> = 3; <span style="color:blue">p</span>-&gt;<span style="color:blue">r</span>-&gt;<span style="color:blue">r</span>-&gt;<span style="color:blue">r</span> = <span style="color:blue">NULL</span></td></tr>
</table></td></tr>
</table>
</div><p>Em <span style="font-family:monospace">Haskell</span>, o acesso a um valor <code><span style="color:blue">v</span></code>, em uma lista <code><span style="color:blue">x</span></code>, requer acesso a
todos os elementos anteriores a <code><span style="color:blue">v</span></code> em <code><span style="color:blue">x</span></code>. De fato, a representação interna de listas definidas em <span style="font-family:monospace">Haskell</span>é feita por meio de ponteiros, mas a manipulação de ponteiros é gerada automaticamente pelo compilador da linguagem, de acordo com o código do programa, em vez de ser feita diretamente pelo programador.</p><p>Uma maneira alternativa de representar listas é por meio de <em>arranjos</em>, 
especialmente em uma linguagem (como <span style="font-family:monospace">C</span>) que não provê suporte a
manipulação de valores de estruturas de dados recursivas. Utilizando essa forma de representação, a lista fica limitada a um número máximo de elementos, já que a defição de uma arranjo requer que o número de elementos do mesmo seja especificado a priori.</p>
<!--TOC subsection id=sec8 Pesquisa-->
<h3 id="sec8" class="subsection">1.1.1  Pesquisa</h3><!--SEC END --><p>
<a id="sec-pesquisa-em-lista"></a></p><p>Em computação, <em>pesquisar</em> em geral significa determinar se um
dado elemento está presente ou não em uma estrutura de dados. As
subseções seguintes tratam de operações de pesquisa, inserção e
remoção de elementos de listas, de acordo com a forma com que listas
são representadas.</p><p>Em ambos os casos apresentados abaixo, a pesquisa em uma lista de <span style="font-style:italic">n</span>
elementos tem complexidade <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span>) no pior caso, pois envolve, possivelmente, comparação com cada elemento da lista.</p>
<!--TOC subsubsection id=sec9 Versão funcional-->
<h4 id="sec9" class="subsubsection">1.1.1.1  Versão funcional</h4><!--SEC END --><p>A função <code><span style="color:blue">elem</span></code>, que determina se um dado valor é elemento de uma lista dada, pode ser definida como a seguir:
<a id="hevea_default1"></a></p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="color:#007F00">elem</span> :: <span style="font-weight:bold"><span style="color:black">Eq</span></span> <span style="color:blue">a</span> =&gt; <span style="color:blue">a</span> -&gt; <span style="color:blue">a</span> -&gt; <span style="font-weight:bold"><span style="color:black">Bool</span></span>
<span style="color:#007F00">elem</span> <span style="color:blue">a</span> []    = <span style="font-weight:bold"><span style="color:black">False</span></span>
<span style="color:#007F00">elem</span> <span style="color:blue">a</span> (<span style="color:blue">b</span>:<span style="color:blue">x</span>) = (<span style="color:blue">a</span> == <span style="color:blue">b</span>) || <span style="color:#007F00">elem</span> <span style="color:blue">a</span> <span style="color:blue">x</span></td></tr>
</table></td></tr>
</table>
</div><p>O tipo de <code><span style="color:blue">elem</span></code>, em <span style="font-family:monospace">Haskell</span>, é um tipo <em>polimórfico restrito</em>: a restrição (<em>constraint</em>) (<code><span style="font-weight:bold"><span style="color:black">Eq</span></span></code><code> </code><code><span style="color:blue">a</span></code>) indica que a variável de tipo <code><span style="color:blue">a</span></code>
não pode ser instanciada para qualquer tipo, mas apenas para um tipo
que é membro da classe de tipos <code><span style="font-weight:bold"><span style="color:black">Eq</span></span></code>, ou seja, no caso, apenas para um
tipo para o qual exista definida uma operação de igualdade <code>(==)</code>, para
valores desse tipo. É um erro de tipo chamar a função <code><span style="color:blue">elem</span></code> com um argumento de um tipo para o qual não é definida comparação de igualdade.</p><hr style="height:2"><p><em>Nota</em>: </p><p>A função <code><span style="color:blue">elem</span></code>, de fato, faz parte do módulo <span style="font-style:italic">Prelude</span>, importado
automaticamente por todos os módulos de programas <span style="font-family:monospace">Haskell</span>, sem necessidade de comando ou cláusula explícita de importação. A definição de <code><span style="color:blue">elem</span></code> no <span style="font-style:italic">Prelude</span> é diferente da apresentada acima, e usa outras funções também definidas no <span style="font-style:italic">Prelude</span>, como <code><span style="color:blue">mmap</span></code> e <code><span style="color:blue">foldr</span></code>, que são ferramentas importantes para definição de outras funções em Haskell. A definição de <code><span style="color:blue">elem</span></code> contida no <span style="font-style:italic">Prelude</span> é apresentada a seguir:</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting">
<span style="color:#007F00">foldr</span>  :: (<span style="color:blue">a</span> -&gt; <span style="color:blue">b</span> -&gt; <span style="color:blue">b</span>) -&gt; <span style="color:blue">b</span> -&gt; [<span style="color:blue">a</span>] -&gt; <span style="color:blue">b</span>
<span style="color:#007F00">foldr</span> <span style="color:blue">f</span> <span style="color:blue">z</span> []    =  <span style="color:blue">z</span>
<span style="color:#007F00">foldr</span> <span style="color:blue">f</span> <span style="color:blue">z</span> (<span style="color:blue">a</span>:<span style="color:blue">x</span>) =  <span style="color:blue">f</span> <span style="color:blue">a</span> (<span style="color:#007F00">foldr</span> <span style="color:blue">f</span> <span style="color:blue">z</span> <span style="color:blue">x</span>)

<span style="color:#007F00">mmap</span> :: (<span style="color:blue">a</span> -&gt; <span style="color:blue">b</span>) -&gt; [<span style="color:blue">a</span>] -&gt; [<span style="color:blue">b</span>]
<span style="color:#007F00">mmap</span> _  []   = []
<span style="color:#007F00">mmap</span> <span style="color:blue">f</span> (<span style="color:blue">a</span>:<span style="color:blue">x</span>) = <span style="color:blue">f</span> <span style="color:blue">a</span> : <span style="color:#007F00">mmap</span> <span style="color:blue">f</span> <span style="color:blue">x</span>

<span style="color:#007F00">and</span>, <span style="color:#007F00">or</span> :: [<span style="font-weight:bold"><span style="color:black">Bool</span></span>] -&gt; <span style="font-weight:bold"><span style="color:black">Bool</span></span>
<span style="color:#007F00">and</span> =  <span style="color:#007F00">foldr</span> (&amp;&amp;) <span style="font-weight:bold"><span style="color:black">True</span></span>
<span style="color:#007F00">or</span>   =  <span style="color:#007F00">foldr</span> (||) <span style="font-weight:bold"><span style="color:black">False</span></span>

<span style="color:#007F00">any</span>, <span style="color:#007F00">all</span> :: (<span style="color:blue">a</span> -&gt; <span style="font-weight:bold"><span style="color:black">Bool</span></span>) -&gt; [<span style="color:blue">a</span>] -&gt; <span style="font-weight:bold"><span style="color:black">Bool</span></span>
<span style="color:#007F00">any</span> <span style="color:blue">p</span> =  <span style="color:#007F00">or</span> . <span style="color:blue">map</span> <span style="color:blue">p</span>
<span style="color:#007F00">all</span> <span style="color:blue">p</span> =  <span style="color:#007F00">and</span> . <span style="color:blue">map</span> <span style="color:blue">p</span>

<span style="color:#007F00">elem</span> :: (<span style="font-weight:bold"><span style="color:black">Eq</span></span> <span style="color:blue">a</span>) =&gt; <span style="color:blue">a</span> -&gt; [<span style="color:blue">a</span>] -&gt; <span style="font-weight:bold"><span style="color:black">Bool</span></span>
<span style="color:#007F00">elem</span> <span style="color:blue">a</span> = <span style="color:#007F00">any</span> (== <span style="color:blue">a</span>)</td></tr>
</table></td></tr>
</table>
</div><hr style="height:2">
<!--TOC subsubsection id=sec10 Versão imperativa-->
<h4 id="sec10" class="subsubsection">1.1.1.2  Versão imperativa</h4><!--SEC END --><p>A versão imperativa de <code><span style="color:blue">elem</span></code> definida a seguir recebe como argumento o valor a ser pesquisado, denotado pelo parâmetro <code><span style="color:blue">a</span></code>, juntamente com um apontador para uma lista (de tipo <code><span style="color:blue">ListaDeInteiros</span></code>), denotado pelo parâmetro <code><span style="color:blue">l</span></code>. O algoritmo retorna retorna um apontador para o elemento da lista <code><span style="color:blue">l</span></code> que é igual a <code><span style="color:blue">a</span></code>, caso o argumento esteja presente na lista, e retorna <code><span style="color:blue">NULL</span></code> em caso contrário.
<a id="hevea_default2"></a></p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="color:#007F00">elem</span> (<span style="color:blue">a</span>, <span style="color:blue">l</span>)
   <span style="font-weight:bold"><span style="color:black">while</span></span> (<span style="color:blue">l</span> != <span style="color:blue">NULL</span> &amp;&amp; <span style="color:blue">l</span>-&gt;<span style="color:#007F00">elem</span> != <span style="color:blue">a</span>) <span style="color:blue">l</span> = <span style="color:blue">l</span>-&gt;<span style="color:blue">r</span>
   <span style="font-weight:bold"><span style="color:black">return</span></span> <span style="color:blue">l</span></td></tr>
</table></td></tr>
</table>
</div>
<!--TOC subsection id=sec11 Inserção-->
<h3 id="sec11" class="subsection">1.1.2  Inserção</h3><!--SEC END --><p>
<a id="sec-insercao-em-lista"></a></p><p>Inserir um elemento no início de uma lista é uma operação de
complexidade <span style="font-style:italic">O</span>(1).</p>
<!--TOC subsubsection id=sec12 Versão funcional-->
<h4 id="sec12" class="subsubsection">1.1.2.1  Versão funcional</h4><!--SEC END --><p>A inserção de um elemento no início da lista é feita simplesmente, por meio do construtor de lista <code>(:)</code>, ou seja:
<a id="hevea_default3"></a></p><div class="center">

<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="color:#007F00">insert</span> = (:)</td></tr>
</table></div>
<!--TOC subsubsection id=sec13 Versão imperativa-->
<h4 id="sec13" class="subsubsection">1.1.2.2  Versão imperativa</h4><!--SEC END --><p>Na versão imperativa, é alocado um novo registro, de tipo <code><span style="color:blue">ListaDeInteiros</span></code>,
para armazenar o novo valor a ser inserido na lista, sendo retornada a lista resultante dessa operação.
<a id="hevea_default4"></a></p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="color:#007F00">insert</span> (<span style="color:blue">a</span>, <span style="color:blue">l</span>)
   <span style="color:blue">p</span> = <span style="color:blue">malloc</span>(<span style="font-weight:bold"><span style="color:black">sizeof</span></span>(<span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="color:blue">ListaDeInteiros</span>))
   <span style="color:blue">p</span>-&gt;<span style="color:blue">elem</span> = <span style="color:blue">a</span>
   <span style="color:blue">p</span>-&gt;<span style="color:blue">r</span> = <span style="color:blue">l</span>
   <span style="font-weight:bold"><span style="color:black">return</span></span> <span style="color:blue">p</span></td></tr>
</table></td></tr>
</table>
</div>
<!--TOC subsection id=sec14 Remoção-->
<h3 id="sec14" class="subsection">1.1.3  Remoção</h3><!--SEC END --><p>
<a id="remocao-de-lista"></a></p><p>Remover um elemento de uma lista é uma operação de complexidade <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span>)
no pior caso, pois é necessário procurar o elemento a ser removido.</p><p>A Seção <a href="#sec-lista-duplamente-encadeada">1.1.4</a> redefine o tipo de lista
encadeada para uma versão de listas duplamente encadeadas, e reescreve
as funções <code><span style="color:blue">elem</span></code> e <code><span style="color:blue">insert</span></code>, para definir <code><span style="font-weight:bold"><span style="color:black">delete</span></span></code> por meio de uma
chamada à função <code><span style="color:blue">elem</span></code>, seguida de chamada a <code><span style="color:blue">insert</span></code>.</p>
<!--TOC subsubsection id=sec15 Versão funcional-->
<h4 id="sec15" class="subsubsection">1.1.3.1  Versão funcional</h4><!--SEC END --><p>A versão funcional cria uma nova lista, que não tem o elemento
passado como parâmetro:
<a id="hevea_default5"></a></p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="color:#007F00">delete</span> :: <span style="font-weight:bold"><span style="color:black">Eq</span></span> <span style="color:blue">a</span> =&gt; <span style="color:blue">a</span> -&gt; [<span style="color:blue">a</span>] -&gt; [<span style="color:blue">a</span>]
<span style="color:#007F00">delete</span> _ [] = []
<span style="color:#007F00">delete</span> <span style="color:blue">a</span> (<span style="color:blue">b</span>:<span style="color:blue">x</span>)
   | <span style="color:blue">a</span> == <span style="color:blue">b</span>    = <span style="color:blue">x</span>
   | <span style="font-weight:bold"><span style="color:black">otherwise</span></span> = <span style="color:blue">b</span>:<span style="color:#007F00">delete</span> <span style="color:blue">a</span> <span style="color:blue">x</span></td></tr>
</table></td></tr>
</table>
</div>
<!--TOC subsubsection id=sec16 Versão imperativa-->
<h4 id="sec16" class="subsubsection">1.1.3.2  Versão imperativa</h4><!--SEC END --><p>A versão imperativa de <code><span style="font-weight:bold"><span style="color:black">delete</span></span></code>, apresentada a seguir, não cria uma nova lista: usa um ponteiro &#X2013; <code><span style="color:blue">prev</span></code> &#X2013; para percorrer a lista até encontrar o elemento a ser removido e, quando este é encontrado, modifica a estrutura de encadeamento da lista, removendo este elemento. </p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="color:#007F00">delete</span> (<span style="color:blue">a</span>, <span style="color:blue">l</span>)
   <span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="color:blue">ListaDeInteiros</span> *<span style="color:blue">prev</span> = <span style="color:blue">NULL</span>;
   *<span style="color:blue">p</span> = <span style="color:blue">l</span>
   <span style="font-weight:bold"><span style="color:black">while</span></span> (<span style="color:blue">p</span> != <span style="color:blue">NULL</span> &amp;&amp; <span style="color:blue">p</span>-&gt;<span style="color:blue">elem</span> != <span style="color:blue">a</span>)
      <span style="color:blue">prev</span> = <span style="color:blue">p</span>
      <span style="color:blue">p</span> = <span style="color:blue">p</span>-&gt;<span style="color:blue">r</span>
      <span style="font-weight:bold"><span style="color:black">if</span></span> (<span style="color:blue">prev</span> == <span style="color:blue">NULL</span>)
         <span style="font-weight:bold"><span style="color:black">return</span></span> <span style="color:blue">l</span>-&gt;<span style="color:blue">r</span>
      <span style="font-weight:bold"><span style="color:black">else</span></span> { <span style="color:blue">prev</span>-&gt;<span style="color:blue">r</span> = <span style="color:blue">p</span>-&gt;<span style="color:blue">r</span>; <span style="font-weight:bold"><span style="color:black">return</span></span> <span style="color:blue">l</span> }</td></tr>
</table></td></tr>
</table>
</div>
<!--TOC subsection id=sec17 Lista duplamente encadeada-->
<h3 id="sec17" class="subsection">1.1.4  Lista duplamente encadeada</h3><!--SEC END --><p>
<a id="sec-lista-duplamente-encadeada"></a></p><p>&#X2026;&#X2026;.....</p>
<!--TOC subsection id=sec18 Pilha-->
<h3 id="sec18" class="subsection">1.1.5  Pilha</h3><!--SEC END --><p>
<a id="pilha"></a>
<a id="hevea_default6"></a></p><p>Uma estrutura de dados <em>Pilha</em> caracteriza-se pelo fato de que as operações de inserção, acesso e remoção de elementos são feitas em apenas
um de seus lados (ou extremidades). Essa política de uso é comumente chamada LIFO (do inglês, <em>last-in first-out</em>: o último a ser inserido é o primeiro a ser removido da pilha. Discutimos, a seguir, a implementação de uma Pilha, com as operações: i) criar pilha vazia, ii) empilhar elemento, iii) desempilhar elemento, iv) obter elemento do topo da pilha, e v) testar se pilha está vazia. É fácil ver que a ordem de complexidade de tempo de cada uma dessas operações é <span style="font-style:italic">O</span>(1).</p>
<!--TOC subsubsection id=sec19 Versão funcional-->
<h4 id="sec19" class="subsubsection">1.1.5.1  Versão funcional</h4><!--SEC END --><p>
<a id="hevea_default7"></a>
Em <span style="font-family:monospace">Haskell</span>, a implementação de <code><span style="color:blue">Pilha</span></code> é obtida diretamente das operações definidas sobre listas, isto é:</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="color:#007F00">vazia</span> = []
<span style="color:#007F00">empilhar</span> = (:)
<span style="color:#007F00">desempilhar</span> (_:<span style="color:blue">x</span>) = <span style="color:blue">x</span>
<span style="color:#007F00">topo</span> (<span style="color:blue">a</span>:_) = <span style="color:blue">a</span>
<span style="color:#007F00">estaVazia</span> = <span style="font-weight:bold"><span style="color:black">null</span></span></td></tr>
</table></td></tr>
</table>
</div><p>Em geral, vamos procurar simplificar o código de nossos programas,
não tratando casos de erro, por motivos didáticos. Entretanto, em programas completos, não podemos esquecer de tratar todos os casos possíveis para os dados de entrada. O módulo <a href="figPilha">Tipo abstrato Pilha</a>, a seguir, implementa esse tipo abstrato, considerando todos esses casos possíveis para os dados de entrada das operações.</p><p>O módulo <code><span style="color:blue">Pilha</span></code> implementa o que é chamado em computação de um <em>tipo abstrato de dados</em>, que é um tipo com operações de criação,
modificação e consulta sobre valores desse tipo. Por exemplo, <code><span style="color:blue">vazia</span></code> é uma operação de criação (nesse caso, a única);
<code><span style="color:blue">empilhar</span></code> e <code><span style="color:blue">desempilhar</span></code> são operações de modificação; <code><span style="color:blue">topo</span></code> e <code><span style="color:blue">estaVazia</span></code> são operações de consulta. </p><p>Em uma definição de um tipo abstrato de dados, a definição de tipo e das operações (para criação, modificação e consulta) sobre valores
do tipo devem ser contidas em um mesmo trecho de programa (em geral,
um módulo), e a representação usada não é &#X201C;visível&#X201D; para quem usa valores do tipo. Ou seja, um tipo abstrato é constituído de um tipo, munido de um conjunto de operações sobre valores desse tipo. Qualquer outra operação sobre valores do tipo apenas pode ser implementada por meio dessas operações previamente definidas.</p><p>Para definir um tipo abstrato <code><span style="color:blue">Pilha</span></code>, em <span style="font-family:monospace">Haskell</span>, usamos uma definição de um novo tipo, introduzida pela palavra-chave <code><span style="font-weight:bold"><span style="color:black">newtype</span></span></code>. O tipo <code><span style="color:blue">Pilha</span></code> possui um único construtor de valores <code><span style="color:blue">mkPilha</span></code> (de mesmo nome do construtor de tipo). Esse mecanismo é usado para ocultar a representação do tipo abstrato: o construtor de que não é exportado pelo módulo em que o tipo é definido: o construtor de valores <code><span style="color:blue">mkPilha</span></code> não é exportado, apenas o construtor de tipos <code><span style="color:blue">Pilha</span></code>. Para melhor legibilidade, definimos também o tipo de cada uma das funções. Veja o código a seguir.
<a id="hevea_default8"></a></p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><div class="center">Listing 1.1: <a id="figPilha"></a>Tipo abstrato Pilha</div><br>
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting">
<span style="font-weight:bold"><span style="color:black">module</span></span> <span style="color:#007F00">Pilha</span> (<span style="color:#007F00">Pilha</span>, <span style="color:#007F00">vazia</span>, <span style="color:#007F00">empilhar</span>, <span style="color:#007F00">desempilhar</span>, <span style="color:#007F00">topo</span>, <span style="color:#007F00">estaVazia</span>) <span style="font-weight:bold"><span style="color:black">where</span></span>
   <span style="font-weight:bold"><span style="color:black">newtype</span></span> <span style="color:#007F00">Pilha</span> <span style="color:blue">a</span> = <span style="color:blue">mkPilha</span> [<span style="color:blue">a</span>]

   <span style="color:#007F00">vazia</span> :: <span style="color:#007F00">Pilha</span> <span style="color:blue">$a</span>
   <span style="color:#007F00">vazia</span> = <span style="color:blue">mkPilha</span> []

   <span style="color:#007F00">empilhar</span> :: <span style="color:blue">a</span> -&gt; <span style="color:#007F00">Pilha</span> <span style="color:blue">a</span> -&gt; <span style="color:#007F00">Pilha</span> <span style="color:blue">a</span>
   <span style="color:#007F00">empilhar</span> <span style="color:blue">e</span> (<span style="color:blue">mkPilha</span> <span style="color:blue">p</span>) = <span style="color:#007F00">Pilha</span> (<span style="color:blue">e</span>:<span style="color:blue">p</span>)

   <span style="color:#007F00">desempilhar</span> :: <span style="color:#007F00">Pilha</span> <span style="color:blue">a</span> -&gt; <span style="color:#007F00">Pilha</span> <span style="color:blue">a</span>
   <span style="color:#007F00">desempilhar</span> (<span style="color:blue">mkPilha</span> [])    = <span style="font-weight:bold"><span style="color:black">error</span></span> "Função desempilhar chamada com pilha vazia"
   <span style="color:#007F00">desempilhar</span> (<span style="color:blue">mkPilha</span> (_:<span style="color:blue">p</span>)) = <span style="color:blue">mkPilha</span> <span style="color:blue">p</span>

   <span style="color:#007F00">topo</span>:: <span style="color:#007F00">Pilha</span> <span style="color:blue">a</span> -&gt; <span style="color:blue">a</span>
   <span style="color:#007F00">topo</span> (<span style="color:blue">mkPilha</span> [])    = <span style="font-weight:bold"><span style="color:black">error</span></span> "Função topo chamada com pilha vazia"
   <span style="color:#007F00">topo</span> (<span style="color:blue">mkPilha</span> (<span style="color:blue">e</span>:_)) = <span style="color:blue">e</span>

   <span style="color:#007F00">estaVazia</span>:: <span style="color:#007F00">Pilha</span> <span style="color:blue">a</span> -&gt; <span style="font-weight:bold"><span style="color:black">Bool</span></span>
   <span style="color:#007F00">estaVazia</span> (<span style="color:blue">mkPilha</span> <span style="color:blue">p</span>) = <span style="font-weight:bold"><span style="color:black">null</span></span> <span style="color:blue">p</span></td></tr>
</table></td></tr>
</table>
</div>
<!--TOC subsubsection id=sec20 Versão imperativa-->
<h4 id="sec20" class="subsubsection">1.1.5.2  Versão imperativa</h4><!--SEC END --><p>
<a id="hevea_default9"></a>
Na versão imperativa, consideramos uma <code><span style="color:blue">pilha</span></code> representada como um registro com dois campos: &#X2208;topo e <code><span style="color:blue">elems</span></code>, sendo <code><span style="color:blue">elems</span></code> um arranjo de <span style="font-style:italic">n</span> elementos (indexado de 0 a <span style="font-style:italic">n</span><span style="font-family:monospace">-1</span>), e <code><span style="color:blue">topo</span></code> uma variável inteira, que indica o índice do último elemento inserido. As operações sobre a <code><span style="color:blue">pilha</span></code> podem ser implementadas como a seguir (desconsiderando-se os casos de erro: desempilhar de uma pilha vazia e empilhar em uma pilha cheia).</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="color:#007F00">vazia</span> (<span style="color:blue">pilha</span>) { <span style="color:blue">pilha</span>.<span style="color:#007F00">topo</span> = -1 }

<span style="color:#007F00">empilhar</span> (<span style="color:blue">e</span>, <span style="color:blue">pilha</span>)
   <span style="font-weight:bold"><span style="color:black">with</span></span> <span style="color:blue">pilha</span> { <span style="color:#007F00">topo</span> = <span style="color:#007F00">topo</span> + 1; <span style="color:blue">elems</span>[<span style="color:#007F00">topo</span>] = <span style="color:blue">e</span> }

<span style="color:#007F00">desempilhar</span> (<span style="color:blue">pilha</span>)
   <span style="font-weight:bold"><span style="color:black">with</span></span> <span style="color:blue">pilha</span> { <span style="color:#007F00">topo</span> = <span style="color:#007F00">topo</span> - 1 }

<span style="color:#007F00">topo</span> (<span style="color:blue">pilha</span>)
   <span style="font-weight:bold"><span style="color:black">with</span></span> <span style="color:blue">pilha</span> { <span style="font-weight:bold"><span style="color:black">return</span></span> <span style="color:blue">elems</span>[<span style="color:#007F00">topo</span>] }

<span style="color:#007F00">estaVazia</span> (<span style="color:blue">pilha</span>) { <span style="font-weight:bold"><span style="color:black">return</span></span> <span style="color:blue">pilha</span>.<span style="color:#007F00">topo</span> == -1 }</td></tr>
</table></td></tr>
</table>
</div><p>O comando <code><span style="font-weight:bold"><span style="color:black">with</span></span></code>, usado no código acima, serve para tornar visíveis os nomes de campos de um registro: <code><span style="font-weight:bold"><span style="color:black">with</span></span></code><code> </code><code><span style="color:blue">r</span></code> evita que se tenha que prefixar os nomes dos campos do registro inar com o nome do registro.
</p>
<!--TOC subsection id=sec21 Fila-->
<h3 id="sec21" class="subsection">1.1.6  Fila</h3><!--SEC END --><p>
<a id="sec-fila"></a>
<a id="hevea_default10"></a>
Em uma <em>Fila</em>, a inserção é feita de um lado e a remoção é feita do
lado oposto da estrutura de dados &#X2013; política de uso algumas
vezes chamada de FIFO (<em>first-in first-out</em>: o primeiro a ser
inserido é o primeiro a ser removido da fila.</p><p>Uma fila, com operações de i) criar fila vazia, ii) entrar (inserir
elemento) na fila, iii) sair (tirar elemento) da fila, iv) obter
primeiro elemento da fila, e v) testar se fila está vazia, pode ser
implementada como se mostra a seguir.</p>
<!--TOC subsubsection id=sec22 Versão funcional-->
<h4 id="sec22" class="subsubsection">1.1.6.1  Versão funcional</h4><!--SEC END --><p>
<a id="hevea_default11"></a>
Não é eficiente fazer acesso ao último elemento de uma lista em
Haskell. Por isso, a implementação padrão de filas por meio de listas usa 
duas listas, <code><span style="color:blue">frente</span></code> e <code><span style="color:blue">tras</span></code>: elementos entram na lista <code><span style="color:blue">tras</span></code> e saem da lista <code><span style="color:blue">frente</span></code>. A função <code><span style="color:blue">fila</span></code> é usada na definição de <code><span style="color:blue">entrar</span></code>, para garantir o invariante de que, se <code><span style="color:blue">frente</span></code> está vazia, então <code><span style="color:blue">tras</span></code> está vazia (e, portanto, a fila está vazia).</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="color:#007F00">vazia</span> = ([],[])

<span style="color:#007F00">entrar</span> <span style="color:blue">e</span> (<span style="color:blue">frente</span>,<span style="color:blue">tras</span>) = <span style="color:#007F00">fila</span> (<span style="color:blue">frente</span>, <span style="color:blue">e</span>:<span style="color:blue">tras</span>)

<span style="color:#007F00">fila</span> ([], <span style="color:blue">tras</span>) = (<span style="font-weight:bold"><span style="color:black">reverse</span></span> <span style="color:blue">tras</span>, [])
<span style="color:#007F00">fila</span> <span style="color:blue">f</span>          = <span style="color:blue">f</span>

<span style="color:#007F00">sair</span> (<span style="color:blue">e</span>:<span style="color:blue">frente</span>, <span style="color:blue">tras</span>) = (<span style="color:blue">frente</span>,<span style="color:blue">tras</span>)

<span style="color:#007F00">primeiro</span> (<span style="color:blue">e</span>:<span style="color:blue">frente</span>,_) = <span style="color:blue">e</span>

<span style="color:#007F00">estaVazia</span> (<span style="color:blue">frente</span>,_)  = <span style="font-weight:bold"><span style="color:black">null</span></span> <span style="color:blue">frente</span></td></tr>
</table></td></tr>
</table>
</div>
<!--TOC subsubsection id=sec23 Versão imperativa-->
<h4 id="sec23" class="subsubsection">1.1.6.2  Versão imperativa</h4><!--SEC END --><p>
<a id="fila-imperativa"></a>
<a id="hevea_default12"></a></p><p>Na versão imperativa, consideramos uma <code><span style="color:blue">fila</span></code> como um registro com campos <code><span style="color:blue">inicio</span></code>, <code><span style="color:blue">fim</span></code> e <code><span style="color:blue">elems</span></code>, sendo <code><span style="color:blue">elems</span></code> um arranjo de <span style="font-style:italic">n</span> elementos (indexado de <span style="font-family:monospace">0</span> a <span style="font-style:italic">n</span><span style="font-family:monospace">-1</span>). Os índices do primeiro e do último elementos inseridos na fila são armazenados respectivamente nas variáveis <code><span style="color:blue">inicio</span></code> e <code><span style="color:blue">fim</span></code>. </p><p>A fila está vazia quando <code><span style="color:blue">inicio</span></code><code> == </code><code><span style="color:blue">fim</span></code>. A fila está cheia
quando <code><span style="color:blue">inicio</span></code><code> == </code><code><span style="color:blue">fim</span></code><code> + 1</code>, isto é, a fila é circular: o
índice <span style="font-family:monospace">0</span> segue o índice <span style="font-style:italic">n</span><span style="font-family:monospace">-1</span>. </p><p>As operações em uma fila podem ser implementadas como a seguir,
desconsiderando-se casos de erro: sair de uma fila vazia e entrar em uma
fila cheia. O operador <span style="font-family:monospace">%</span>, usado na implementação, retorna o resto da
divisão do primeiro operando pelo segundo.</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="color:#007F00">vazia</span> (<span style="color:#007F00">fila</span>) { <span style="font-weight:bold"><span style="color:black">with</span></span> <span style="color:#007F00">fila</span> { <span style="color:blue">inicio</span> = <span style="color:blue">fim</span> = 0 } }

<span style="color:#007F00">entrar</span> (<span style="color:blue">e</span>, <span style="color:#007F00">fila</span>)
   <span style="font-weight:bold"><span style="color:black">with</span></span> <span style="color:#007F00">fila</span>
      <span style="color:blue">elems</span>[<span style="color:blue">fim</span>] = <span style="color:blue">e</span>
      <span style="color:blue">fim</span> = (<span style="color:blue">fim</span> + 1) % <span style="color:blue">n</span>

<span style="color:#007F00">sair</span> (<span style="color:#007F00">fila</span>) { <span style="font-weight:bold"><span style="color:black">with</span></span> <span style="color:#007F00">fila</span> { <span style="color:blue">inicio</span> = (<span style="color:blue">inicio</span> + 1) % <span style="color:blue">n</span> } }

<span style="color:#007F00">primeiro</span> (<span style="color:#007F00">fila</span>) { <span style="font-weight:bold"><span style="color:black">return</span></span> <span style="color:#007F00">fila</span>.<span style="color:blue">elems</span>[<span style="color:blue">inicio</span>] }

<span style="color:#007F00">estaVazia</span> (<span style="color:#007F00">fila</span>) { <span style="font-weight:bold"><span style="color:black">with</span></span> <span style="color:#007F00">fila</span> { <span style="font-weight:bold"><span style="color:black">return</span></span> <span style="color:blue">inicio</span> == <span style="color:blue">fim</span> } }</td></tr>
</table></td></tr>
</table>
</div>
<!--TOC section id=sec24 Árvores-->
<h2 id="sec24" class="section">1.2  Árvores</h2><!--SEC END --><p>
<a id="arvores"></a>
<a id="hevea_default13"></a></p><p>Uma árvore pode ser vista como uma estrutura de dados recursiva, definida como sendo ou i) vazia (uma folha) ou ii) um nodo contendo um elemento e um certo número de ramos (ou nodos), que contêm sub-árvores:</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-weight:bold"><span style="color:black">data</span></span> <span style="color:#007F00">Tree</span> <span style="color:blue">a</span> = <span style="color:#007F00">Leaf</span> | <span style="color:#007F00">Node</span> <span style="color:blue">a</span> [<span style="color:#007F00">Tree</span> <span style="color:blue">a</span>]</td></tr>
</table></td></tr>
</table>
</div><p>Na definição acima, o construtor <code><span style="color:blue">Leaf</span></code> constrói uma árvore vazia, ou folha, e o construtor <code><span style="color:blue">Node</span></code> constrói uma árvore contendo uma informação de tipo <code><span style="color:blue">a</span></code> e um lista de subárvores.</p><p>Outra possível definição considera que a informação é armazenada nas folhas, em vez de nos nodos internos:</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-weight:bold"><span style="color:black">data</span></span> <span style="color:#007F00">Tree</span>' <span style="color:blue">a</span> = <span style="color:#007F00">Leaf</span>' <span style="color:blue">a</span> | <span style="color:#007F00">Node</span>' [<span style="color:#007F00">Tree</span>' <span style="color:blue">a</span>]</td></tr>
</table></td></tr>
</table>
</div><p>Uma árvore com exatamente duas sub-árvores (possivelmente vazias) é chamada de árvore binária e pode ser definida como:</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"> <span style="font-weight:bold"><span style="color:black">data</span></span> <span style="color:#007F00">BTree</span> <span style="color:blue">a</span> = <span style="color:#007F00">BLeaf</span> <span style="color:blue">a</span> | <span style="color:#007F00">BNode</span> (<span style="color:#007F00">BTree</span> <span style="color:blue">a</span>) (<span style="color:#007F00">BTree</span> <span style="color:blue">a</span>)</td></tr>
</table></td></tr>
</table>
</div><p>Em linguagens que provêem suporte ao uso de ponteiros, mas não à
definição e manipulação direta de tipos recursivos, a representação de
árvores binárias pode ser feita com o uso de ponteiro como mostra o
exemplo a seguir:</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="color:#007F00">ArvoreBinariaDeInteiros</span>
     <span style="font-weight:bold"><span style="color:black">int</span></span> <span style="color:blue">elem</span>
     <span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="color:#007F00">ArvoreBinariaDeInteiros</span> *<span style="color:blue">esq</span>, <span style="color:blue">dir</span></td></tr>
</table></td></tr>
</table>
</div><p>Os campos <code><span style="color:blue">esq</span></code> e <code><span style="color:blue">dir</span></code> de um nodo são ponteiros, possivelmente nulos,
para sub-árvores.</p><p>Para árvores não binárias, pode ser usada a seguinte representação, que
podemos chamar de <em>representação com primogênito-irmão-e-pai</em>:</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >
<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="color:#007F00">ArvoreDeInteiros</span>
   <span style="font-weight:bold"><span style="color:black">int</span></span> <span style="color:blue">elem</span>;
   <span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="color:#007F00">ArvoreDeInteiros</span> *<span style="color:blue">primogenito</span>, <span style="color:blue">irmao</span>, <span style="color:blue">pai</span></td></tr>
</table></td></tr>
</table>
</div><p>A representação da árvore da Figura <a href="#Arv1">1.1</a> é mostrada na Figura <a href="#Rep-arv1">1.2</a>.</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div><p>xxxx
</p><div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figura 1.1: Árvore exemplo</td></tr>
</table></div><p>
<a id="Arv1"></a>
</p><div class="center"><hr style="width:80%;height:2"></div></blockquote><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div><p>yyyyy
</p><div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figura 1.2: Representação da árvore exemplo por valor do tipo <code><span style="color:blue">ArvoreDeInteiros</span></code></td></tr>
</table></div><p>
<a id="Rep-arv1"></a>
</p><div class="center"><hr style="width:80%;height:2"></div></blockquote><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<hr style="height:2"><blockquote class="quote"><em>Este documento foi traduzido de L<sup>A</sup>T<sub>E</sub>X por
</em><a href="http://hevea.inria.fr/index.html"><em>H</em><em><span style="font-size:small"><sup>E</sup></span></em><em>V</em><em><span style="font-size:small"><sup>E</sup></span></em><em>A</em></a><em>.</em></blockquote></body>
</html>
