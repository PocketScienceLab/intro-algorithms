<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="generator" content="hevea 2.00">
<style type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding 0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding0 tr td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
.myclisting{font-family:monospace;white-space:pre;margin:lex;padding:2ex;}
body{background-color:white}
a:link{color:#00A3B2;text-decoration:underline;}
a:visited{color:#005D66;text-decoration:underline;}
a:hover{color:black;text-decoration:none;background-color:#99F6FF}
.title{padding:1ex;background-color:#00A3B2}
.titlemain{padding:1ex;background-color:#00A3B2}
.titlerest{padding:1ex;background-color:#00A3B2}
.part{padding:1ex;background-color:#00BBCC}
.section{padding:.5ex;background-color:#66F2FF}
.subsection{padding:0.3ex;background-color:#7FF4FF}
.subsubsection{padding:0.5ex;background-color:#99F6FF}
.paragraph{padding:0.5ex;background-color:#CCFAFF}
.chapter{padding:0.5ex;background-color:#2DD6E5}
.fmarginpar{border:solid thin #7FF4FF; width:20%; text-align:left}
.ffootnoterule{border:none;margin:1em auto 1em 0px;width:50%;background-color:#00BBCC}
.ftoc1{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #00BBCC}
.ftoc2{list-style:none;margin:1ex 1ex;padding:0ex 1ex;border-left:1ex solid #2DD6E5}
.ftoc3{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #66F2FF}
.ftoc4{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #7FF4FF}
.ftoc5{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #99F6FF}
.ftoc6{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #CCFAFF}
</style>
<title> Introdução a Algoritmos 

</title>
</head>
<body >
<!--HEVEA command line is: hevea livro index -->
<!--CUT STYLE book--><!--HTMLHEAD-->
<span style="font-variant:small-caps"><span style="font-weight:bold"><span style="font-size:small">Introdução a Algoritmos</span></span></span>:<!--ENDHTML-->
<!--CUT DEF chapter 1 --><table class="title"><tr><td><h1 class="titlemain"><span style="font-variant:small-caps"> </span><span style="font-variant:small-caps">Introdução a Algoritmos</span><br>
</h1><h3 class="titlerest">Carlos Camarão<br>
<span style="font-size:small">Universidade Federal de Minas Gerais</span><br>
<span style="font-size:small">Doutor em Ciência da Computação pela Universidade de Manchester, Inglaterra</span><br>
<span style="font-size:small">©</span><span style="font-size:small"> 2015</span> </h3></td></tr>
</table><p>É permitida a duplicação ou reprodução, no todo ou em parte, sob
quaisquer formas ou por quaisquer meios (eletrônico, mecânico,
gravação, fotocópia, distribuição na Web ou outros), desde que seja
para fins não comerciais.</p><!--TOC chapter id=sec1 Conteúdo-->
<h1 id="sec1" class="chapter">Conteúdo</h1><!--SEC END --><ul class="ftoc1"><li class="li-toc">
<a href="#sec2"><span style="background-color:aqua">Prefácio</span></a>
<ul class="ftoc2">
<ul class="ftoc3"><li class="li-toc">
<a href="#sec3">Conteúdo e Organização do Livro</a>
</li><li class="li-toc"><a href="#sec4">Recursos Adicionais</a>
</li><li class="li-toc"><a href="#sec5">Pré-requisitos</a>
</li></ul>
</ul>
</li><li class="li-toc"><a href="#sec6">Capítulo 1  <span style="background-color:aqua">Introdução</span></a>
<ul class="ftoc2"><li class="li-toc">
<a href="#sec7">1.1  Ordenação</a>
<ul class="ftoc3"><li class="li-toc">
<a href="#sec8">1.1.1  Sobre Permutação</a>
</li></ul>
</li><li class="li-toc"><a href="#sec9">1.2  Ordenação por Inserção</a>
<ul class="ftoc3"><li class="li-toc">
<a href="#sec10">1.2.1  Versão funcional</a>
</li><li class="li-toc"><a href="#sec11">1.2.2  Versão imperativa</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec12">Capítulo 2  <span style="background-color:aqua">Estruturas de Dados Básicas</span></a>
<ul class="ftoc2"><li class="li-toc">
<a href="#sec13">2.1  Listas</a>
<ul class="ftoc3"><li class="li-toc">
<a href="#sec14">2.1.1  Pesquisa</a>
<ul class="ftoc4"><li class="li-toc">
<a href="#sec15">2.1.1.1  Versão funcional</a>
</li><li class="li-toc"><a href="#sec16">2.1.1.2  Versão imperativa</a>
</li></ul>
</li><li class="li-toc"><a href="#sec17">2.1.2  Inserção</a>
<ul class="ftoc4"><li class="li-toc">
<a href="#sec18">2.1.2.1  Versão funcional</a>
</li><li class="li-toc"><a href="#sec19">2.1.2.2  Versão imperativa</a>
</li></ul>
</li><li class="li-toc"><a href="#sec20">2.1.3  Remoção</a>
<ul class="ftoc4"><li class="li-toc">
<a href="#sec21">2.1.3.1  Versão funcional</a>
</li><li class="li-toc"><a href="#sec22">2.1.3.2  Versão imperativa</a>
</li></ul>
</li><li class="li-toc"><a href="#sec23">2.1.4  Lista duplamente encadeada</a>
</li><li class="li-toc"><a href="#sec24">2.1.5  Pilha</a>
<ul class="ftoc4"><li class="li-toc">
<a href="#sec25">2.1.5.1  Versão funcional</a>
</li></ul>
</li></ul>
</li></ul>
</li></ul>
<!--TOC chapter id=sec2 <span style="background-color:aqua">Prefácio</span>-->
<h1 id="sec2" class="chapter"><span style="background-color:aqua">Prefácio</span></h1><!--SEC END --><p>Este livro provê uma introdução ao estudo de algoritmos. Ele apresenta
estruturas de dados básicas e algoritmos de pesquisa e ordenação, e
provê uma introdução ao importante ramo da ciência da computação que
trata do desenvolvimento e análise da eficiência de algoritmos. O
assunto da análise de eficiência é comumente chamado em computação de
complexidade.</p><p>Essa análise aborda em geral quanto tempo é gasto na execução de um
algoritmo em função do tamanho da entrada: diz-se complexidade de
tempo do algoritmo. Além do tempo, pode ser analisada também a
complexidade de espaço (quanto espaço de memória é gasto na execução
em função do tamanho da entrada).</p><p>... notação ...</p><p>... funcional ...</p><p>... clareza, concisão ...</p>
<!--TOC subsection id=sec3 Conteúdo e Organização do Livro-->
<h3 id="sec3" class="subsection">Conteúdo e Organização do Livro</h3><!--SEC END -->
<!--TOC subsection id=sec4 Recursos Adicionais-->
<h3 id="sec4" class="subsection">Recursos Adicionais</h3><!--SEC END -->
<!--TOC subsection id=sec5 Pré-requisitos-->
<h3 id="sec5" class="subsection">Pré-requisitos</h3><!--SEC END --><p>Os pré-requsitos são:</p><ol class="enumerate" type=1><li class="li-enumerate">Experiência inicial com provas por indução. (??)</li></ol>
<!--TOC chapter id=sec6 <span style="background-color:aqua">Introdução</span>-->
<h1 id="sec6" class="chapter">Capítulo 1  <span style="background-color:aqua">Introdução</span></h1><!--SEC END --><p>
<a id="Introducao"></a></p><p>Este livro provê uma introdução ao estudo de algoritmos, apresentando
introdução a estruturas de dados básicas, algoritmos de pesquisa e de
ordenação e noções de análise de complexidade de algoritmos.</p><p>Um algoritmo pode ser visto como uma função, no sentido de que mapeia
cada valor de de (um conjunto de valores de) entrada um único valor de
(um conjunto de valores de) saída.</p><p>A diferença que existe entre o conceito usual de função é a notação
usualmente empregada para especificação da sequência de passos. Em
computação, é usual o emprego de uma notação ou linguagem <em>imperativa</em>, ao passo que usualmente definições de funções
empregam uma notação mais <em>declarativa</em>, ou <em>funcional</em>.</p><p>Um algoritmo pode ser descrito usando-se diferentes abordagens e
notação. Neste livro, vamos descrever algoritmos tanto em
<em>notação funcional</em> quanto em <em>notação imperativa</em>. A
descrição em notação funcional poderá ser desconsiderada em cursos que
desejam abordar apenas o paradigma de programação imperativo. No
entanto, a descrição funcional muitas vezes contribui para melhor
compreensão da versão imperativa. A notação funcional utilizada aqui é
a linguagem <span style="font-family:monospace">Haskell</span>&#X226; notação imperativa é um pseudo-código
semelhante às linguagens <span style="font-family:monospace">C</span>, <span style="font-family:monospace">Pascal</span> ou <span style="font-family:monospace">Java</span>. Usamos endentação para
indicar aninhamento no pseudo-código, sendo comandos, assim como
campos internos em definições de tipos, separados por mudança de
linha, em vez de serem usadas chaves com comandos terminados por
ponto-e-vírgula.</p><p>A notação funcional será explicada sempre que necessário, isto é,
sempre que houver alguma possibilidade de dúvida. Uma descrição
sucinta da linguagem Haskell é incluída no Apêndice <a href="#Ap-Haskell">??</a>,
que deverá ser lido pelo leitor não familiarizado com essa
linguagem. Descrições mais completas de Haskell podem ser encontradas,
por exemplo, em
[<a href="#PeytonJones92"></a>, <a href="#Thompson99"></a>, <a href="#O%27Sullivan%3A2008%3ARWH"></a>, <a href="#Lipovaca%3A2011%3ALYH"></a>].</p>
<!--TOC section id=sec7 Ordenação-->
<h2 id="sec7" class="section">1.1  Ordenação</h2><!--SEC END --><p><a id="hevea_default0"></a></p><p>Considere o problema de ordenação, especificado formalmente como a seguir (um problema computacional especifica a relação que deve existir entre a
entrada e a saída):</p><p><span style="font-weight:bold">Entrada</span>: sequência de elementos <span style="font-style:italic">S</span><sub>0</sub>.</p><p><span style="font-weight:bold">Saída</span>: sequência de elementos ordenada <span style="font-style:italic">S</span> tal que <span style="font-style:italic">S</span> é uma
permutação de <span style="font-style:italic">S</span><sub>0</sub>.</p><p>Uma sequência <span style="font-style:italic">a</span><sub>1</sub>, &#X2026;, <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> é ordenada se <span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span></sub> &#X2264; <span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span>+1</sub> para
<span style="font-style:italic">i</span>=1,&#X2026;, <span style="font-style:italic">n</span>&#X2212;1.</p>
<!--TOC subsection id=sec8 Sobre Permutação-->
<h3 id="sec8" class="subsection">1.1.1  Sobre Permutação</h3><!--SEC END --><p><a id="hevea_default1"></a></p><p>Uma <em>permutação</em> é uma redisposição dos elementos em uma certa sequência. Por exemplo, existem 6 permutações distintas dos elementos
1,2,3, que são: (1,2,3), (1,3,2), (2,1,3), (2,3,1), (3,1,2), (3,2,1).</p><p>Outra denominação, usada no contexto de palavras, é <em>anagrama</em>. 
Um anagrama é o resultado de rearranjar as letras de uma palavra ou
frase para produzir uma nova palavra ou frase, usando cada uma das
letras originais exatamente uma vez. Por exemplo, "ovo" é um anagrama
de "voo".
<a id="hevea_default2"></a></p><p>Permutações ocorrem em diversas áreas da matemática e proeminentemente
no estudo de algoritmos, particularmente de algoritmos ordenação.</p><p>O número de permutações de <span style="font-style:italic">n</span> elementos distintos é igual ao fatorial
de <span style="font-style:italic">n</span> (usualmente escrito como <span style="font-style:italic">n</span>!), ou seja, o produto de todos os
inteiros positivos menores ou iguais a <span style="font-style:italic">n</span>. Para ver isso, observe
que existem <span style="font-style:italic">n</span> possíveis maneiras de escolher o primeiro elemento de
uma permutação de <span style="font-style:italic">n</span> elementos. Para cada possível escolha do
primeiro elemento, temos <span style="font-style:italic">n</span>&#X2212;1 possíveis maneiras de escolher o
segundo elemento da permutação. Portanto, temos <span style="font-style:italic">n</span> (<span style="font-style:italic">n</span>&#X2212;1) maneiras de
escolher os dois primeiros elementos. Temos então <span style="font-style:italic">n</span>&#X2212;2 maneiras de
escolher o terceiro elemento da permutação, ou seja, 
<span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>&#X2212;1)(<span style="font-style:italic">n</span>&#X2212;2) possíveis maneiras de escolher os três primeiros
elementos. E assim sucessivamente, até que reste apenas um último
elemento, o que nos dá um total de <span style="font-style:italic">n</span>!=<span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>&#X2212;1)&#X2026; 1 possíveis permutações distintas.</p>
<!--TOC section id=sec9 Ordenação por Inserção-->
<h2 id="sec9" class="section">1.2  Ordenação por Inserção</h2><!--SEC END --><p><a id="hevea_default3"></a>
Um algoritmo para solução do problema de ordenação
especificado acima, chamado de <em>ordenação por inserção</em>, é
mostrado a seguir. Ele reflete o modo como um jogador de baralho
usualmente ordena uma sequência de cartas em suas mãos (por exemplo, em
um jogo de buraco).</p>
<!--TOC subsection id=sec10 Versão funcional-->
<h3 id="sec10" class="subsection">1.2.1  Versão funcional</h3><!--SEC END --><p>
<a id="insertion-sort-func"></a></p><p><a id="hevea_default4"></a>
<a id="hevea_default5"></a></p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >

<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-style:italic"><span style="color:#007F00">sort</span></span> []    = []
<span style="font-style:italic"><span style="color:#007F00">sort</span></span> (<span style="font-style:italic"><span style="color:blue">a</span></span>:<span style="font-style:italic"><span style="color:blue">x</span></span>) = <span style="font-style:italic"><span style="color:#007F00">insert</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> (<span style="font-style:italic"><span style="color:#007F00">sort</span></span> <span style="font-style:italic"><span style="color:blue">x</span></span>)

<span style="font-style:italic"><span style="color:#007F00">insert</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> [] = []
<span style="font-style:italic"><span style="color:#007F00">insert</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> (<span style="font-style:italic"><span style="color:blue">b</span></span>:<span style="font-style:italic"><span style="color:blue">x</span></span>)
   | <span style="font-style:italic"><span style="color:blue">a</span></span> &lt;= <span style="font-style:italic"><span style="color:blue">b</span></span>    = <span style="font-style:italic"><span style="color:blue">a</span></span>:(<span style="font-style:italic"><span style="color:blue">b</span></span>:<span style="font-style:italic"><span style="color:blue">x</span></span>)
   | <span style="font-weight:bold"><span style="color:black">otherwise</span></span> = <span style="font-style:italic"><span style="color:blue">b</span></span>:<span style="font-style:italic"><span style="color:#007F00">insert</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> <span style="font-style:italic"><span style="color:blue">x</span></span></td></tr>
</table></td></tr>
</table>
</div><p>Explicações sobre a notação funcional (usada em Haskell):</p><ol class="enumerate" type=1><li class="li-enumerate"><a id="hevea_default6"></a> <code><span style="font-style:italic"><span style="color:blue">f</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code> (aplicação funcional &#X2014;
a base da programação funcional) é o mesmo que §f(x)§ (mas melhor
porque evita os parênteses).</li><li class="li-enumerate"><code><span style="font-style:italic"><span style="color:blue">b</span></span></code><code>:</code><code><span style="font-style:italic"><span style="color:blue">insert</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code>  é o mesmo que <code><span style="font-style:italic"><span style="color:blue">b</span></span></code><code>:(</code><code><span style="font-style:italic"><span style="color:blue">insert</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code><code>)</code> : a aplicação funcional tem precedência sobre o uso de
</li><li class="li-enumerate"><a id="hevea_default7"></a> O uso de um operador binário nada
mais é do que uma variação sintática de (açúcar sintático para) uma
aplicação funcional; o uso de um operador binário pode ser
transformado em uma aplicação funcional, e vice-versa. Para
transformar um operador binário em uma aplicação funcional, basta
colocar o operador entre parênteses, e para transformar uma
aplicação funcional em um operador, basta colocar o nome da função
entre crases. Exemplos:<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" > <code>2 + 3</code></td><td style="text-align:left;white-space:nowrap" >é equivalente a</td><td style="text-align:left;white-space:nowrap" ><code>(+) 2 3</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <code><span style="font-style:italic"><span style="color:blue">b</span></span></code><code>:</code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code></td><td style="text-align:left;white-space:nowrap" >é equivalente a</td><td style="text-align:left;white-space:nowrap" ><code>(:) </code><code><span style="font-style:italic"><span style="color:blue">b</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <code><span style="font-style:italic"><span style="color:blue">f</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">y</span></span></code></td><td style="text-align:left;white-space:nowrap" >é equivalente a</td><td style="text-align:left;white-space:nowrap" ><code><span style="font-style:italic"><span style="color:blue">x</span></span></code><code> `</code><code><span style="font-style:italic"><span style="color:blue">f</span></span></code><code>` </code><code><span style="font-style:italic"><span style="color:blue">y</span></span></code> 
</td></tr>
</table></li><li class="li-enumerate"><a id="hevea_default8"></a> <a id="hevea_default9"></a><a id="hevea_default10"></a><a id="hevea_default11"></a> As
funções <code><span style="font-style:italic"><span style="color:blue">insert</span></span></code> e <code><span style="font-style:italic"><span style="color:blue">sort</span></span></code> usam listas, um tipo recursivo, que é um
tipo de dado algébrico (chamado em Haskell de <code><span style="font-weight:bold"><span style="color:black">data</span></span></code>) parecido com o
seguinte:<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >

<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-weight:bold"><span style="color:black">data</span></span> <span style="font-style:italic"><span style="color:#007F00">List</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> = <span style="font-style:italic"><span style="color:#007F00">Nil</span></span> | <span style="font-style:italic"><span style="color:#007F00">Cons</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> (<span style="font-style:italic"><span style="color:#007F00">List</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span>)</td></tr>
</table></td></tr>
</table>
</div><p><a id="hevea_default12"></a> Um tipo de dado algébrico é a maneira
como se definem somas (de tipos, sendo que só podem existir somas
disjuntas de tipos), que modelam escolha (&#X201C;ou&#X201D;) de tipos de dados.</p><p><a id="hevea_default13"></a><a id="hevea_default14"></a> A declaração de
<code><span style="font-style:italic"><span style="color:blue">List</span></span></code> acima especifica que um valor de tipo lista é polimórfico (o
uso da variável de tipo <code><span style="font-style:italic"><span style="color:blue">a</span></span></code> indica que <code><span style="font-style:italic"><span style="color:blue">List</span></span></code> é um construtor de
tipos que pode ser aplicado a <em>qualquer</em> tipo <code><span style="font-style:italic"><span style="color:blue">t</span></span></code>, isto é,
podemos ter qualquer instância <code><span style="font-style:italic"><span style="color:blue">List</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">t</span></span></code>, para <em>qualquer</em>
tipo <code><span style="font-style:italic"><span style="color:blue">t</span></span></code>), e que uma lista (um valor de tipo <code><span style="font-style:italic"><span style="color:blue">List</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">t</span></span></code>, para algum
tipo <code><span style="font-style:italic"><span style="color:blue">t</span></span></code>) pode ser <code><span style="font-style:italic"><span style="color:blue">Nil</span></span></code> (uma lista vazia) <em>ou</em> <code><span style="font-style:italic"><span style="color:blue">Cons</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">v</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code>, uma lista (não vazia) formada por um valor <code><span style="font-style:italic"><span style="color:blue">v</span></span></code>
(cabeça da lista) e de um restante (ou rabo) da lista, <code><span style="font-style:italic"><span style="color:blue">x</span></span></code> (que deve
ser do mesmo tipo da lista da qual é o restante).</p><p><a id="hevea_default15"></a><a id="hevea_default16"></a><a id="hevea_default17"></a></p><p>O tipo de listas em Haskell (é parecido mas) difere ligeiramente do
tipo algébrico acima porque o construtor <code><span style="font-style:italic"><span style="color:blue">Nil</span></span></code> é escrito como <code>[]</code> e o construtor <code><span style="font-style:italic"><span style="color:blue">Cons</span></span></code> é escrito como um operador binário <code>(:)</code>. Assim, em vez de escrever, <code><span style="font-style:italic"><span style="color:blue">Cons</span></span></code><code> 1 </code><code><span style="font-style:italic"><span style="color:blue">Nil</span></span></code>, escreve-se em
Haskell <code>1:[]</code>. Além disso, pode-se escrever também <code>[1,2,3]</code> em vez de <code>1:2:3:[]</code> &#X2014; i.e. em vez de <code>1:(2:(3:[]))</code>.</p></li><li class="li-enumerate"><a id="hevea_default18"></a> <a id="hevea_default19"></a> Tipos de dados
algébricos permitem definir somas (disjuntas) de tipos, que modelam
escolha (&#X201C;ou&#X201D;) de tipos de dados. Para definir produtos de tipos,
podemos usar tipos algébricos, que permitem produtos
&#X201C;linearizados&#X201D; (também chamados de &#X201C;currificados&#X201D;) ou produtos
cartesianos (generalizados), também chamados de tuplas.<p><a id="hevea_default20"></a> Por exemplo:</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >

<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-weight:bold"><span style="color:black">data</span></span> <span style="font-style:italic"><span style="color:#007F00">Pair</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> <span style="font-style:italic"><span style="color:blue">b</span></span> = <span style="font-style:italic"><span style="color:#007F00">Pair</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> <span style="font-style:italic"><span style="color:blue">b</span></span></td></tr>
</table></td></tr>
</table>
</div><p>define um construtor de tipos <code><span style="font-style:italic"><span style="color:blue">Pair</span></span></code>, que tem dois parâmetros que
podem ser instanciados para quaisquer tipos <code><span style="font-style:italic"><span style="color:blue">t</span></span></code> e <code><span style="font-style:italic"><span style="color:blue">t</span></span></code><code>'</code>: por exemplo,
<code><span style="font-style:italic"><span style="color:blue">Pair</span></span></code><code> </code><code><span style="font-weight:bold"><span style="color:black">Int</span></span></code><code> </code><code><span style="font-weight:bold"><span style="color:black">Bool</span></span></code> representa pares de valores de inteiros e
booleanos (o primeiro componente do par é um inteiro e o segundo um
valor booleano). É semelhante ao produto <code>(</code><code><span style="font-weight:bold"><span style="color:black">Int</span></span></code><code>,</code><code><span style="font-weight:bold"><span style="color:black">Bool</span></span></code><code>)</code>. A
diferença é que valores do primeiro são construídos da forma <code><span style="font-style:italic"><span style="color:blue">Pair</span></span></code><code> 1 </code><code><span style="font-weight:bold"><span style="color:black">True</span></span></code> (especificando um valor inteiro e em seguida um
valor booleano), ao passo que valores do segundo são construídos da
forma <code>(1,</code><code><span style="font-weight:bold"><span style="color:black">True</span></span></code><code>)</code> (especificando, entre parânteses, primeiro um
valor inteiro, seguido de uma vírgula, e depois um valor booleano).</p></li></ol><p>Vamos mostrar que a definição de <code><span style="font-style:italic"><span style="color:blue">sort</span></span></code>, acima, é correta, isto é, que o resultado é uma permutação ordenada (em ordem não decrescente) da lista original. Essa propriedade de correção pode ser expressa formalmente como
</p><div class="center">
<code><span style="font-style:italic"><span style="color:blue">sort</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code> = <code><span style="font-style:italic"><span style="color:blue">y</span></span></code>   implica   <code><span style="font-style:italic"><span style="color:blue">sorted</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">y</span></span></code>   e   <code><span style="font-style:italic"><span style="color:blue">y</span></span></code><code> `</code><code><span style="font-style:italic"><span style="color:blue">perm</span></span></code><code>` </code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code>
</div><p>
onde <code><span style="font-style:italic"><span style="color:blue">sorted</span></span></code> e <code><span style="font-style:italic"><span style="color:blue">perm</span></span></code> são os seguintes predicados (funções de
contra-domínio <code><span style="font-weight:bold"><span style="color:black">Bool</span></span></code>) sobre listas: </p><ul class="itemize"><li class="li-itemize">
<code><span style="font-style:italic"><span style="color:blue">sorted</span></span></code><code> :: [</code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code><code>] -&gt; </code><code><span style="font-weight:bold"><span style="color:black">Bool</span></span></code> retorna <code><span style="font-weight:bold"><span style="color:black">True</span></span></code> se a lista dada como argumento está ordenada em ordem não decrescente, e retorna <code><span style="font-weight:bold"><span style="color:black">False</span></span></code> em caso contrário.
</li><li class="li-itemize"><code><span style="font-style:italic"><span style="color:blue">perm</span></span></code><code> :: [</code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code><code>] -&gt; [</code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code><code>] -&gt; </code><code><span style="font-weight:bold"><span style="color:black">Bool</span></span></code> retorna <code><span style="font-weight:bold"><span style="color:black">True</span></span></code> se a lista dada como primeiro argumento é uma permutação da lista dada como segundo argumento, e retorna <code><span style="font-weight:bold"><span style="color:black">False</span></span></code> em caso contrário.
</li></ul><p>As definições desses predicados são apresentadas a seguir, onde <code><span style="font-style:italic"><span style="color:blue">perm</span></span></code> faz uso de duas outras funções: </p><ul class="itemize"><li class="li-itemize">
<code><span style="font-style:italic"><span style="color:blue">elem</span></span></code><code> :: </code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code><code> -&gt; [</code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code><code>] -&gt; </code><code><span style="font-weight:bold"><span style="color:black">Bool</span></span></code> retorna <code><span style="font-weight:bold"><span style="color:black">True</span></span></code> se a o valor dado como primeiro argumento ocorre na lista dada como segundo argumento, e retorna <code><span style="font-weight:bold"><span style="color:black">False</span></span></code> em caso contrário.</li><li class="li-itemize"><code><span style="font-style:italic"><span style="color:blue">delete</span></span></code><code> :: </code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code><code> -&gt; [</code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code><code>] -&gt; [</code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code><code>]</code> que retorna a lista obtida removendo-se, da lista dada como segundo argumento, a primeira ocorrência do valor dado como primeiro argumento, retornando a lista original caso este valor não ocorra na lista.</li></ul><p><a id="hevea_default21"></a>
<a id="hevea_default22"></a>
<a id="hevea_default23"></a>
<a id="hevea_default24"></a></p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >

<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting">
<span style="font-style:italic"><span style="color:#007F00">sorted</span></span> []      =  <span style="font-weight:bold"><span style="color:black">True</span></span>
<span style="font-style:italic"><span style="color:#007F00">sorted</span></span> [<span style="font-style:italic"><span style="color:blue">a</span></span>]     =  <span style="font-weight:bold"><span style="color:black">True</span></span>
<span style="font-style:italic"><span style="color:#007F00">sorted</span></span> (<span style="font-style:italic"><span style="color:blue">a</span></span>:<span style="font-style:italic"><span style="color:blue">b</span></span>:<span style="font-style:italic"><span style="color:blue">x</span></span>) = (<span style="font-style:italic"><span style="color:blue">a</span></span> &lt;= <span style="font-style:italic"><span style="color:blue">b</span></span>) &amp;&amp; <span style="font-style:italic"><span style="color:#007F00">sorted</span></span> (<span style="font-style:italic"><span style="color:blue">b</span></span>:<span style="font-style:italic"><span style="color:blue">x</span></span>)

[] `<span style="font-style:italic"><span style="color:#007F00">perm</span></span>`  []  = <span style="font-weight:bold"><span style="color:black">True</span></span>
(<span style="font-style:italic"><span style="color:blue">a</span></span>:<span style="font-style:italic"><span style="color:blue">x</span></span>) `<span style="font-style:italic"><span style="color:#007F00">perm</span></span>` <span style="font-style:italic"><span style="color:blue">y</span></span> = <span style="font-style:italic"><span style="color:#007F00">elem</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> <span style="font-style:italic"><span style="color:blue">y</span></span> &amp;&amp; (<span style="font-style:italic"><span style="color:blue">x</span></span> `<span style="font-style:italic"><span style="color:#007F00">perm</span></span>` (<span style="font-style:italic"><span style="color:#007F00">delete</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> <span style="font-style:italic"><span style="color:blue">y</span></span>))

<span style="font-style:italic"><span style="color:blue">a</span></span> `<span style="font-style:italic"><span style="color:#007F00">elem</span></span>` []    = <span style="font-weight:bold"><span style="color:black">False</span></span>
<span style="font-style:italic"><span style="color:blue">a</span></span> `<span style="font-style:italic"><span style="color:#007F00">elem</span></span>` (<span style="font-style:italic"><span style="color:blue">b</span></span>:<span style="font-style:italic"><span style="color:blue">x</span></span>) = (<span style="font-style:italic"><span style="color:blue">a</span></span> == <span style="font-style:italic"><span style="color:blue">b</span></span>) || (<span style="font-style:italic"><span style="color:blue">a</span></span> `<span style="font-style:italic"><span style="color:#007F00">elem</span></span>` <span style="font-style:italic"><span style="color:blue">x</span></span>)

<span style="font-style:italic"><span style="color:#007F00">delete</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> [] = []
<span style="font-style:italic"><span style="color:#007F00">delete</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> (<span style="font-style:italic"><span style="color:blue">b</span></span>:<span style="font-style:italic"><span style="color:blue">x</span></span>)
   | <span style="font-style:italic"><span style="color:blue">a</span></span>==<span style="font-style:italic"><span style="color:blue">b</span></span>      = <span style="font-style:italic"><span style="color:blue">x</span></span>
   | <span style="font-weight:bold"><span style="color:black">otherwise</span></span> = <span style="font-style:italic"><span style="color:blue">b</span></span>:<span style="font-style:italic"><span style="color:#007F00">delete</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> <span style="font-style:italic"><span style="color:blue">x</span></span></td></tr>
</table></td></tr>
</table>
</div><p>Explicações sobre a notação funcional (usada em Haskell):</p><ol class="enumerate" type=1><li class="li-enumerate"><code>&amp;&amp;</code> e <code>||</code> são operadores binários lógicos de
conjunção e disjunção, respectivamente.</li><li class="li-enumerate">A definição de <code><span style="font-style:italic"><span style="color:blue">delete</span></span></code> usa <em>guardas</em>, que são expressões
booleanas usadas na definição de funções. Para cada chamada de
função, a primeira (na ordem textual) guarda cuja avaliação retorna
<code><span style="font-weight:bold"><span style="color:black">True</span></span></code> define o resultado da chamada da função, pela avaliação da
expressão associada a essa guarda (que segue o símbolo <span style="font-family:monospace">=</span>). Por
exemplo, a guarda na definição de <code><span style="font-style:italic"><span style="color:blue">delete</span></span></code> é equivalente a:
<code><span style="font-weight:bold"><span style="color:black">if</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code><code>==</code><code><span style="font-style:italic"><span style="color:blue">b</span></span></code><code> </code><code><span style="font-weight:bold"><span style="color:black">then</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code><code> </code><code><span style="font-weight:bold"><span style="color:black">else</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">b</span></span></code><code>:</code><code><span style="font-style:italic"><span style="color:blue">delete</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code>.</li></ol><p><span style="font-weight:bold">Prova da correção de </span><code><span style="font-weight:bold"><span style="font-style:italic"><span style="color:blue">sort</span></span></span></code>: A prova é por indução sobre a estrutura de construção de listas (ou sobre o comprimento da lista). O caso base, correspondente à lista vazia, pode ser provado diretamente. O caso indutivo é obtido como consequência
dos seguintes lemas:
</p><ul class="itemize"><li class="li-itemize">
Lema 1: Para todo <code><span style="font-style:italic"><span style="color:blue">a</span></span></code>,<code><span style="font-style:italic"><span style="color:blue">x</span></span></code>, 
<code>(</code><code><span style="font-style:italic"><span style="color:blue">sorted</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code><code>)</code> implica <code>(</code><code><span style="font-style:italic"><span style="color:blue">sorted</span></span></code><code> (</code><code><span style="font-style:italic"><span style="color:blue">insert</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code><code>))</code></li><li class="li-itemize">Lema 2: Para todo <code><span style="font-style:italic"><span style="color:blue">a</span></span></code>,<code><span style="font-style:italic"><span style="color:blue">x</span></span></code>, 
<code>(</code><code><span style="font-style:italic"><span style="color:blue">sort</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code><code>) `</code><code><span style="font-style:italic"><span style="color:blue">perm</span></span></code><code>` </code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code> implica 
<code>(</code><code><span style="font-style:italic"><span style="color:blue">insert</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code><code> (</code><code><span style="font-style:italic"><span style="color:blue">sort</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code><code>)) `</code><code><span style="font-style:italic"><span style="color:blue">perm</span></span></code><code>` (</code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code><code>:</code><code><span style="font-style:italic"><span style="color:blue">x</span></span></code><code>)</code>
</li></ul>
<!--TOC subsection id=sec11 Versão imperativa-->
<h3 id="sec11" class="subsection">1.2.2  Versão imperativa</h3><!--SEC END --><p>
<a id="insertion-sort-imperativ"></a></p><p>A versão imperativa usa o próprio arranjo para a ordenação (nenhum
outro arranjo ou estrutura de dados auxiliar) e a seguinte ideia:</p><blockquote class="quotation">
insere <code><span style="font-style:italic"><span style="color:blue">A</span></span></code><code>[</code><code><span style="font-style:italic"><span style="color:blue">j</span></span></code><code>]</code> no arranjo ordenado de <code><span style="font-style:italic"><span style="color:blue">A</span></span></code><code>[1]</code> até
<code><span style="font-style:italic"><span style="color:blue">A</span></span></code><code>[</code><code><span style="font-style:italic"><span style="color:blue">j</span></span></code><code>-1]</code>, de <code><span style="font-style:italic"><span style="color:blue">j</span></span></code><code>=2</code> até o tamanho do arranjo
</blockquote><p>A ideia dá origem ao seguinte algoritmo, escrito em pseudo-código como
(note que endentação no pseudo-código indica aninhamento na estrutura
de blocos):</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >

<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-style:italic"><span style="color:#007F00">sort</span></span>(<span style="font-style:italic"><span style="color:blue">A</span></span>)
   <span style="font-weight:bold"><span style="color:black">for</span></span> <span style="font-style:italic"><span style="color:blue">j</span></span>:=2 <span style="font-style:italic"><span style="color:blue">to</span></span> <span style="font-style:italic"><span style="color:blue">length</span></span>[<span style="font-style:italic"><span style="color:blue">A</span></span>] <span style="font-weight:bold"><span style="color:black">do</span></span>
      <span style="font-style:italic"><span style="color:blue">key</span></span> := <span style="font-style:italic"><span style="color:blue">A</span></span>[<span style="font-style:italic"><span style="color:blue">j</span></span>]
      <span style="color:red">/* Insere A[j] no arranjo ordenado A[1..j-1] */</span>
      <span style="font-style:italic"><span style="color:blue">i</span></span> := <span style="font-style:italic"><span style="color:blue">j</span></span>-1
      <span style="font-weight:bold"><span style="color:black">while</span></span> (<span style="font-style:italic"><span style="color:blue">i</span></span> &gt; 0 &amp;&amp; <span style="font-style:italic"><span style="color:blue">A</span></span>[<span style="font-style:italic"><span style="color:blue">i</span></span>]&gt;<span style="font-style:italic"><span style="color:blue">key</span></span>) <span style="font-weight:bold"><span style="color:black">do</span></span>
         <span style="font-style:italic"><span style="color:blue">A</span></span>[<span style="font-style:italic"><span style="color:blue">i</span></span>+1] := <span style="font-style:italic"><span style="color:blue">A</span></span>[<span style="font-style:italic"><span style="color:blue">i</span></span>]
         <span style="font-style:italic"><span style="color:blue">i</span></span> := <span style="font-style:italic"><span style="color:blue">i</span></span> - 1
         <span style="font-style:italic"><span style="color:blue">A</span></span>[<span style="font-style:italic"><span style="color:blue">i</span></span>+1] := <span style="font-style:italic"><span style="color:blue">key</span></span></td></tr>
</table></td></tr>
</table>
</div><p>
<a id="hevea_default25"></a>
<a id="hevea_default26"></a></p><p>A correção do algoritmo advém de que o invariante, especificado
bastante informalmente como:</p><blockquote class="quotation">
&#X2014; no início da execução de cada iteração do comando <code><span style="font-weight:bold"><span style="color:black">for</span></span></code>, o
sub-arranjo <code><span style="font-style:italic"><span style="color:blue">A</span></span></code><code>[1..</code><code><span style="font-style:italic"><span style="color:blue">j</span></span></code><code>-1]</code> contém os elementos que estavam
originalmente nesse sub-arranjo, mas de forma ordenada &#X2014;
</blockquote><p>é verdadeiro no início (antes da execução da primeira iteração do
<code><span style="font-weight:bold"><span style="color:black">for</span></span></code>), antes e após cada iteração, e no final, quando então a
terminação garante a correção do algoritmo (ordenamento de todo o
arranjo).</p><p>É importante observar que a transformação dessa prova informal em uma
prova formal é relativamente muito mais difícil do que no caso
funcional.</p><p>No próximo capítulo vamos introduzir introduzir a notação e os
conceitos principais usados para análise da complexidade (eficiência)
de algoritmos, para que possamos analisar a complexidade de algoritmos
(começando pela complexidade dos algoritmos apresentados neste
capítulo).</p>
<!--TOC chapter id=sec12 <span style="background-color:aqua">Estruturas de Dados Básicas</span>-->
<h1 id="sec12" class="chapter">Capítulo 2  <span style="background-color:aqua">Estruturas de Dados Básicas</span></h1><!--SEC END --><p>
<a id="estruturas-de-dados-basicas"></a></p><p>Este capítulo aborda listas e árvores, suas representações em um computador e
operações básicas sobre essas estruturas de dados.</p>
<!--TOC section id=sec13 Listas-->
<h2 id="sec13" class="section">2.1  Listas</h2><!--SEC END --><p>
<a id="listas"></a></p><p>Uma lista é uma estrutura de dados comumente usada em computação e pode ser definida recursivamente como a seguir. Uma lista de elementos de
determinado tipo <code><span style="font-style:italic"><span style="color:blue">t</span></span></code> é ou i) <em>vazia</em> ou ii) constituída de um elemento de tipo <code><span style="font-style:italic"><span style="color:blue">t</span></span></code> e um uma lista de elementos do mesmo tipo <code><span style="font-style:italic"><span style="color:blue">t</span></span></code> (denominada <em>cauda</em> ou resto da lista).</p><p>Em uma linguagem como Haskell, que provê suporte à definição de tipos
de dados recursivos, o tipo lista pode ser definido como:</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >

<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-weight:bold"><span style="color:black">data</span></span> <span style="font-style:italic"><span style="color:#007F00">List</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> = <span style="font-style:italic"><span style="color:#007F00">Nil</span></span> | <span style="font-style:italic"><span style="color:#007F00">Cons</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> (<span style="font-style:italic"><span style="color:#007F00">List</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span>)</td></tr>
</table></td></tr>
</table>
</div><p>O tipo de dado <code>\</code><code><span style="font-style:italic"><span style="color:blue">List</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code> é um tipo recursivo, sendo <code><span style="font-style:italic"><span style="color:blue">Nil</span></span></code> e <code><span style="font-style:italic"><span style="color:blue">Cons</span></span></code> os construtores de valores desse tipo. Além disso, <code>\</code><code><span style="font-style:italic"><span style="color:blue">List</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code> é um tipo <em>polimórfico</em>: a variável de tipo <code><span style="font-style:italic"><span style="color:blue">a</span></span></code> pode ser instanciada para um tipo <code><span style="font-style:italic"><span style="color:blue">t</span></span></code> qualquer, permitindo assim a definição de listas com elementos de desse tipo <code><span style="font-style:italic"><span style="color:blue">t</span></span></code>. Por exemplo, <code>(</code><code><span style="font-style:italic"><span style="color:blue">Cons</span></span></code><code> 1 (</code><code><span style="font-style:italic"><span style="color:blue">Cons</span></span></code><code> 2 (</code><code><span style="font-style:italic"><span style="color:blue">Cons</span></span></code><code> 3 </code><code><span style="font-style:italic"><span style="color:blue">Nil</span></span></code><code>)))</code> é uma lista de tipo <code><span style="font-style:italic"><span style="color:blue">List</span></span></code><code> </code><code><span style="font-weight:bold"><span style="color:black">Int</span></span></code> e <code>(</code><code><span style="font-style:italic"><span style="color:blue">Cons</span></span></code><code> </code><code><span style="font-weight:bold"><span style="color:black">True</span></span></code><code> (</code><code><span style="font-style:italic"><span style="color:blue">Cons</span></span></code><code> </code><code><span style="font-weight:bold"><span style="color:black">False</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">Nil</span></span></code><code>))</code> tem tipo <code><span style="font-style:italic"><span style="color:blue">List</span></span></code><code> </code><code><span style="font-weight:bold"><span style="color:black">Bool</span></span></code>. </p><p>A linguagem Haskell provê uma notação especial para a criação de valores de tipo lista: <code>[]</code> é usado em lugar de <code><span style="font-style:italic"><span style="color:blue">Nil</span></span></code>, e o construtor infixado <code>(:)</code>, associativo à direita, em lugar de <code><span style="font-style:italic"><span style="color:blue">Cons</span></span></code>. Por exemplo, a lista <code><span style="font-style:italic"><span style="color:blue">Cons</span></span></code><code> 1 (</code><code><span style="font-style:italic"><span style="color:blue">Cons</span></span></code><code> 2 (</code><code><span style="font-style:italic"><span style="color:blue">Cons</span></span></code><code> 3 </code><code><span style="font-style:italic"><span style="color:blue">Nil</span></span></code><code>))</code> seria representada como <code>(1:2:3:[]</code>. 
Além disso, uma lista pode ser representada simplesmente escrevendo-se os seus elementos da lista entre colchetes, separados por vírgulas. Ou seja, a lista <code>\</code><code><span style="font-style:italic"><span style="color:blue">inh</span></span></code><code>{(1:2:3:[]}</code> pode ser escrita, mais simplesmente, como <code>[1,2,3]</code>. </p><p>Em linguagens como <span style="font-family:monospace">C</span>, uma lista pode ser representada por meio de <em>registros</em> (também chamados de "estruturas", em <span style="font-family:monospace">C</span>) e <em>ponteiros</em> (ou apontadores), tal como ilustrado no exemplo a seguir, que define uma lista de elementos de tipo <code><span style="font-weight:bold"><span style="color:black">int</span></span></code>. Linguagens como <span style="font-family:monospace">C</span>, que não provêm suporte para polimorfismo, requerem a definição de tipos lista distintos para cada tipo particular de elementos. </p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >

<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="font-style:italic"><span style="color:#007F00">ListaDeInteiros</span></span>
   <span style="font-weight:bold"><span style="color:black">int</span></span> <span style="font-style:italic"><span style="color:blue">elem</span></span>;
   <span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="font-style:italic"><span style="color:#007F00">ListaDeInteiros</span></span> *<span style="font-style:italic"><span style="color:blue">r</span></span>;</td></tr>
</table></td></tr>
</table>
</div><p>Uma definição de registro, em <span style="font-family:monospace">C</span>, é introduzida pela palavra-chave <code><span style="font-weight:bold"><span style="color:black">struct</span></span></code>, seguida do nome do registro &#X2013; neste caso, <code><span style="font-style:italic"><span style="color:blue">ListaDeInteiros</span></span></code>. O registro possui dois campos: um campo de tipo <code><span style="font-weight:bold"><span style="color:black">int</span></span></code> e nome <code><span style="font-style:italic"><span style="color:blue">elem</span></span></code>, e um campo de nome <code><span style="font-style:italic"><span style="color:blue">r</span></span></code>, que é um ponteiro para valores do próprio tipo <code><span style="font-style:italic"><span style="color:blue">ListaDeInteiros</span></span></code>. </p><p>A manipulação de valores de tipo lista em <span style="font-family:monospace">C</span> é bem mais trabalhosa. A falta de suporte para definição e uso de tipos recursivos e polimórficos torna a programação mais difícil e demorada e o código menos legível e mais sujeito a repetições e a ocorrências de erros. Por exemplo, para criar um valor de tipo <code><span style="font-style:italic"><span style="color:blue">ListaDeInteiros</span></span></code>, com os elementos <code>1,2,3</code>, é necessário código como o seguinte:
<a id="hevea_default27"></a></p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >

<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="font-style:italic"><span style="color:#007F00">ListaDeInteiros</span></span> *<span style="font-style:italic"><span style="color:blue">p</span></span> =
   <span style="font-style:italic"><span style="color:blue">malloc</span></span>(<span style="font-weight:bold"><span style="color:black">sizeof</span></span>(<span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="font-style:italic"><span style="color:#007F00">ListaDeInteiros</span></span>))
   <span style="font-style:italic"><span style="color:blue">p</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">elem</span></span> = 1;       <span style="font-style:italic"><span style="color:blue">p</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">r</span></span> = <span style="font-style:italic"><span style="color:blue">malloc</span></span>(<span style="font-weight:bold"><span style="color:black">sizeof</span></span>(<span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="font-style:italic"><span style="color:#007F00">ListaDeInteiros</span></span>))
   <span style="font-style:italic"><span style="color:blue">p</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">r</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">elem</span></span> = 2;    <span style="font-style:italic"><span style="color:blue">p</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">r</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">r</span></span> = <span style="font-style:italic"><span style="color:blue">malloc</span></span>(<span style="font-weight:bold"><span style="color:black">sizeof</span></span>(<span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="font-style:italic"><span style="color:#007F00">ListaDeInteiros</span></span>))
   <span style="font-style:italic"><span style="color:blue">p</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">r</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">r</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">elem</span></span> = 3; <span style="font-style:italic"><span style="color:blue">p</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">r</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">r</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">r</span></span> = <span style="font-style:italic"><span style="color:blue">NULL</span></span></td></tr>
</table></td></tr>
</table>
</div><p>Em <span style="font-family:monospace">Haskell</span>, o acesso a um valor <code><span style="font-style:italic"><span style="color:blue">v</span></span></code>, em uma lista <code><span style="font-style:italic"><span style="color:blue">x</span></span></code>, requer acesso a
todos os elementos anteriores a <code><span style="font-style:italic"><span style="color:blue">v</span></span></code> em <code><span style="font-style:italic"><span style="color:blue">x</span></span></code>. De fato, a representação interna de listas definidas em <span style="font-family:monospace">Haskell</span>é feita por meio de ponteiros, mas a manipulação de ponteiros é gerada automaticamente pelo compilador da linguagem, de acordo com o código do programa, em vez de ser feita diretamente pelo programador.</p><p>Uma maneira alternativa de representar listas é por meio de <em>arranjos</em>, 
especialmente em uma linguagem (como <span style="font-family:monospace">C</span>) que não provê suporte a
manipulação de valores de estruturas de dados recursivas. Utilizando essa forma de representação, a lista fica limitada a um número máximo de elementos, já que a defição de uma arranjo requer que o número de elementos do mesmo seja especificado a priori.</p>
<!--TOC subsection id=sec14 Pesquisa-->
<h3 id="sec14" class="subsection">2.1.1  Pesquisa</h3><!--SEC END --><p>
<a id="pesquisa-em-lista"></a></p><p>Em computação, <em>pesquisar</em> em geral significa determinar se um
dado elemento está presente ou não em uma estrutura de dados. As
subseções seguintes tratam de operações de pesquisa, inserção e
remoção de elementos de listas, de acordo com a forma com que listas
são representadas.</p><p>Em ambos os casos apresentados abaixo, a pesquisa em uma lista de <span style="font-style:italic">n</span>
elementos tem complexidade <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span>) no pior caso, pois envolve, possivelmente, comparação com cada elemento da lista.</p>
<!--TOC subsubsection id=sec15 Versão funcional-->
<h4 id="sec15" class="subsubsection">2.1.1.1  Versão funcional</h4><!--SEC END --><p>A função <code><span style="font-style:italic"><span style="color:blue">elem</span></span></code>, que determina se um dado valor é elemento de uma lista dada, pode ser definida como a seguir:
<a id="hevea_default28"></a></p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >

<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-style:italic"><span style="color:#007F00">elem</span></span> :: <span style="font-weight:bold"><span style="color:black">Eq</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> =&gt; <span style="font-style:italic"><span style="color:blue">a</span></span> -&gt; <span style="font-style:italic"><span style="color:blue">a</span></span> -&gt; <span style="font-weight:bold"><span style="color:black">Bool</span></span>
<span style="font-style:italic"><span style="color:#007F00">elem</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> []    = <span style="font-weight:bold"><span style="color:black">False</span></span>
<span style="font-style:italic"><span style="color:#007F00">elem</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> (<span style="font-style:italic"><span style="color:blue">b</span></span>:<span style="font-style:italic"><span style="color:blue">x</span></span>) = (<span style="font-style:italic"><span style="color:blue">a</span></span> == <span style="font-style:italic"><span style="color:blue">b</span></span>) || <span style="font-style:italic"><span style="color:#007F00">elem</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> <span style="font-style:italic"><span style="color:blue">x</span></span></td></tr>
</table></td></tr>
</table>
</div><p>O tipo de <code><span style="font-style:italic"><span style="color:blue">elem</span></span></code>, em <span style="font-family:monospace">Haskell</span>, é um tipo <em>polimórfico restrito</em>: a restrição (<em>constraint</em>) (<code><span style="font-weight:bold"><span style="color:black">Eq</span></span></code><code> </code><code><span style="font-style:italic"><span style="color:blue">a</span></span></code>) indica que a variável de tipo <code><span style="font-style:italic"><span style="color:blue">a</span></span></code>
não pode ser instanciada para qualquer tipo, mas apenas para um tipo
que é membro da classe de tipos <code><span style="font-weight:bold"><span style="color:black">Eq</span></span></code>, ou seja, no caso, apenas para um
tipo para o qual exista definida uma operação de igualdade <code>(==)</code>, para
valores desse tipo. É um erro de tipo chamar a função <code><span style="font-style:italic"><span style="color:blue">elem</span></span></code> com um argumento de um tipo para o qual não é definida comparação de igualdade.</p><hr style="height:2"><p><em>Nota</em>: </p><p>A função <code><span style="font-style:italic"><span style="color:blue">elem</span></span></code>, de fato, faz parte do módulo <span style="font-style:italic">Prelude</span>, importado
automaticamente por todos os módulos de programas <span style="font-family:monospace">Haskell</span>, sem necessidade de comando ou cláusula explícita de importação. A definição de <code><span style="font-style:italic"><span style="color:blue">elem</span></span></code> no <span style="font-style:italic">Prelude</span> é diferente da apresentada acima, e usa outras funções também definidas no <span style="font-style:italic">Prelude</span>, como <code><span style="font-style:italic"><span style="color:blue">mmap</span></span></code> e <code><span style="font-style:italic"><span style="color:blue">foldr</span></span></code>, que são ferramentas importantes para definição de outras funções em Haskell. A definição de <code><span style="font-style:italic"><span style="color:blue">elem</span></span></code> contida no <span style="font-style:italic">Prelude</span> é apresentada a seguir:</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >

<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-style:italic"><span style="color:#007F00">foldr</span></span>  :: (<span style="font-style:italic"><span style="color:blue">a</span></span> -&gt; <span style="font-style:italic"><span style="color:blue">b</span></span> -&gt; <span style="font-style:italic"><span style="color:blue">b</span></span>) -&gt; <span style="font-style:italic"><span style="color:blue">b</span></span> -&gt; [<span style="font-style:italic"><span style="color:blue">a</span></span>] -&gt; <span style="font-style:italic"><span style="color:blue">b</span></span>
<span style="font-style:italic"><span style="color:#007F00">foldr</span></span> <span style="font-style:italic"><span style="color:blue">f</span></span> <span style="font-style:italic"><span style="color:blue">z</span></span> []    =  <span style="font-style:italic"><span style="color:blue">z</span></span>
<span style="font-style:italic"><span style="color:#007F00">foldr</span></span> <span style="font-style:italic"><span style="color:blue">f</span></span> <span style="font-style:italic"><span style="color:blue">z</span></span> (<span style="font-style:italic"><span style="color:blue">a</span></span>:<span style="font-style:italic"><span style="color:blue">x</span></span>) =  <span style="font-style:italic"><span style="color:blue">f</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> (<span style="font-style:italic"><span style="color:#007F00">foldr</span></span> <span style="font-style:italic"><span style="color:blue">f</span></span> <span style="font-style:italic"><span style="color:blue">z</span></span> <span style="font-style:italic"><span style="color:blue">x</span></span>)

<span style="font-style:italic"><span style="color:#007F00">mmap</span></span> :: (<span style="font-style:italic"><span style="color:blue">a</span></span> -&gt; <span style="font-style:italic"><span style="color:blue">b</span></span>) -&gt; [<span style="font-style:italic"><span style="color:blue">a</span></span>] -&gt; [<span style="font-style:italic"><span style="color:blue">b</span></span>]
<span style="font-style:italic"><span style="color:#007F00">mmap</span></span> _  []   = []
<span style="font-style:italic"><span style="color:#007F00">mmap</span></span> <span style="font-style:italic"><span style="color:blue">f</span></span> (<span style="font-style:italic"><span style="color:blue">a</span></span>:<span style="font-style:italic"><span style="color:blue">x</span></span>) = <span style="font-style:italic"><span style="color:blue">f</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> : <span style="font-style:italic"><span style="color:#007F00">mmap</span></span> <span style="font-style:italic"><span style="color:blue">f</span></span> <span style="font-style:italic"><span style="color:blue">x</span></span>

<span style="font-style:italic"><span style="color:#007F00">and</span></span>, <span style="font-style:italic"><span style="color:#007F00">or</span></span> :: [<span style="font-weight:bold"><span style="color:black">Bool</span></span>] -&gt; <span style="font-weight:bold"><span style="color:black">Bool</span></span>
<span style="font-style:italic"><span style="color:#007F00">and</span></span> =  <span style="font-style:italic"><span style="color:#007F00">foldr</span></span> (&amp;&amp;) <span style="font-weight:bold"><span style="color:black">True</span></span>
<span style="font-style:italic"><span style="color:#007F00">or</span></span>   =  <span style="font-style:italic"><span style="color:#007F00">foldr</span></span> (||) <span style="font-weight:bold"><span style="color:black">False</span></span>

<span style="font-style:italic"><span style="color:#007F00">any</span></span>, <span style="font-style:italic"><span style="color:#007F00">all</span></span> :: (<span style="font-style:italic"><span style="color:blue">a</span></span> -&gt; <span style="font-weight:bold"><span style="color:black">Bool</span></span>) -&gt; [<span style="font-style:italic"><span style="color:blue">a</span></span>] -&gt; <span style="font-weight:bold"><span style="color:black">Bool</span></span>
<span style="font-style:italic"><span style="color:#007F00">any</span></span> <span style="font-style:italic"><span style="color:blue">p</span></span> =  <span style="font-style:italic"><span style="color:#007F00">or</span></span> . <span style="font-style:italic"><span style="color:blue">map</span></span> <span style="font-style:italic"><span style="color:blue">p</span></span>
<span style="font-style:italic"><span style="color:#007F00">all</span></span> <span style="font-style:italic"><span style="color:blue">p</span></span> =  <span style="font-style:italic"><span style="color:#007F00">and</span></span> . <span style="font-style:italic"><span style="color:blue">map</span></span> <span style="font-style:italic"><span style="color:blue">p</span></span>

<span style="font-style:italic"><span style="color:#007F00">elem</span></span> :: (<span style="font-weight:bold"><span style="color:black">Eq</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span>) =&gt; <span style="font-style:italic"><span style="color:blue">a</span></span> -&gt; [<span style="font-style:italic"><span style="color:blue">a</span></span>] -&gt; <span style="font-weight:bold"><span style="color:black">Bool</span></span>
<span style="font-style:italic"><span style="color:#007F00">elem</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> = <span style="font-style:italic"><span style="color:#007F00">any</span></span> (== <span style="font-style:italic"><span style="color:blue">a</span></span>)</td></tr>
</table></td></tr>
</table>
</div><hr style="height:2">
<!--TOC subsubsection id=sec16 Versão imperativa-->
<h4 id="sec16" class="subsubsection">2.1.1.2  Versão imperativa</h4><!--SEC END --><p>A versão imperativa de <code><span style="font-style:italic"><span style="color:blue">elem</span></span></code> definida a seguir recebe como argumento o valor a ser pesquisado, denotado pelo parâmetro <code><span style="font-style:italic"><span style="color:blue">a</span></span></code>, juntamente com um apontador para uma lista (de tipo <code><span style="font-style:italic"><span style="color:blue">ListaDeInteiros</span></span></code>), denotado pelo parâmetro <code><span style="font-style:italic"><span style="color:blue">l</span></span></code>. O algoritmo retorna retorna um apontador para o elemento da lista <code><span style="font-style:italic"><span style="color:blue">l</span></span></code> que é igual a <code><span style="font-style:italic"><span style="color:blue">a</span></span></code>, caso o argumento esteja presente na lista, e retorna <code><span style="font-style:italic"><span style="color:blue">NULL</span></span></code> em caso contrário.
<a id="hevea_default29"></a></p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >

<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-style:italic"><span style="color:#007F00">elem</span></span> (<span style="font-style:italic"><span style="color:blue">a</span></span>, <span style="font-style:italic"><span style="color:blue">l</span></span>)
   <span style="font-weight:bold"><span style="color:black">while</span></span> (<span style="font-style:italic"><span style="color:blue">l</span></span> != <span style="font-style:italic"><span style="color:blue">NULL</span></span> &amp;&amp; <span style="font-style:italic"><span style="color:blue">l</span></span>-&gt;<span style="font-style:italic"><span style="color:#007F00">elem</span></span> != <span style="font-style:italic"><span style="color:blue">a</span></span>) <span style="font-style:italic"><span style="color:blue">l</span></span> = <span style="font-style:italic"><span style="color:blue">l</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">r</span></span>
   <span style="font-weight:bold"><span style="color:black">return</span></span> <span style="font-style:italic"><span style="color:blue">l</span></span></td></tr>
</table></td></tr>
</table>
</div>
<!--TOC subsection id=sec17 Inserção-->
<h3 id="sec17" class="subsection">2.1.2  Inserção</h3><!--SEC END --><p>
<a id="insercao-em-lista"></a></p><p>Inserir um elemento no início de uma lista é uma operação de
complexidade <span style="font-style:italic">O</span>(1).</p>
<!--TOC subsubsection id=sec18 Versão funcional-->
<h4 id="sec18" class="subsubsection">2.1.2.1  Versão funcional</h4><!--SEC END --><p>A inserção de um elemento no início da lista é feita simplesmente, por meio do construtor de lista <code>(:)</code>, ou seja:
<a id="hevea_default30"></a></p><div class="center">


<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-style:italic"><span style="color:#007F00">insert</span></span> = (:)</td></tr>
</table></div>
<!--TOC subsubsection id=sec19 Versão imperativa-->
<h4 id="sec19" class="subsubsection">2.1.2.2  Versão imperativa</h4><!--SEC END --><p>Na versão imperativa, é alocado um novo registro, de tipo <code><span style="font-style:italic"><span style="color:blue">ListaDeInteiros</span></span></code>,
para armazenar o novo valor a ser inserido na lista, sendo retornada a lista resultante dessa operação.
<a id="hevea_default31"></a></p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >

<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-style:italic"><span style="color:#007F00">insert</span></span> (<span style="font-style:italic"><span style="color:blue">a</span></span>, <span style="font-style:italic"><span style="color:blue">l</span></span>)
   <span style="font-style:italic"><span style="color:blue">p</span></span> = <span style="font-style:italic"><span style="color:blue">malloc</span></span>(<span style="font-weight:bold"><span style="color:black">sizeof</span></span>(<span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="font-style:italic"><span style="color:blue">ListaDeInteiros</span></span>))
   <span style="font-style:italic"><span style="color:blue">p</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">elem</span></span> = <span style="font-style:italic"><span style="color:blue">a</span></span>
   <span style="font-style:italic"><span style="color:blue">p</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">r</span></span> = <span style="font-style:italic"><span style="color:blue">l</span></span>
   <span style="font-weight:bold"><span style="color:black">return</span></span> <span style="font-style:italic"><span style="color:blue">p</span></span></td></tr>
</table></td></tr>
</table>
</div>
<!--TOC subsection id=sec20 Remoção-->
<h3 id="sec20" class="subsection">2.1.3  Remoção</h3><!--SEC END --><p>
<a id="remocao-de-lista"></a></p><p>Remover um elemento de uma lista é uma operação de complexidade <span style="font-style:italic">O</span>(<span style="font-style:italic">n</span>)
no pior caso, pois é necessário procurar o elemento a ser removido.</p><p>A Seção <a href="#lista-duplamente-encadeada">2.1.4</a> redefine o tipo de lista
encadeada para uma versão de listas duplamente encadeadas, e reescreve
as funções <code><span style="font-style:italic"><span style="color:blue">elem</span></span></code> e <code><span style="font-style:italic"><span style="color:blue">insert</span></span></code>, para definir <code><span style="font-weight:bold"><span style="color:black">delete</span></span></code> por meio de uma
chamada à função <code><span style="font-style:italic"><span style="color:blue">elem</span></span></code>, seguida de chamada a <code><span style="font-style:italic"><span style="color:blue">insert</span></span></code>.</p>
<!--TOC subsubsection id=sec21 Versão funcional-->
<h4 id="sec21" class="subsubsection">2.1.3.1  Versão funcional</h4><!--SEC END --><p>A versão funcional cria uma nova lista, que não tem o elemento
passado como parâmetro:
<a id="hevea_default32"></a></p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >

<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-style:italic"><span style="color:#007F00">delete</span></span> :: <span style="font-weight:bold"><span style="color:black">Eq</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> =&gt; <span style="font-style:italic"><span style="color:blue">a</span></span> -&gt; [<span style="font-style:italic"><span style="color:blue">a</span></span>] -&gt; [<span style="font-style:italic"><span style="color:blue">a</span></span>]
<span style="font-style:italic"><span style="color:#007F00">delete</span></span> _ [] = []
<span style="font-style:italic"><span style="color:#007F00">delete</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> (<span style="font-style:italic"><span style="color:blue">b</span></span>:<span style="font-style:italic"><span style="color:blue">x</span></span>)
   | <span style="font-style:italic"><span style="color:blue">a</span></span> == <span style="font-style:italic"><span style="color:blue">b</span></span>    = <span style="font-style:italic"><span style="color:blue">x</span></span>
   | <span style="font-weight:bold"><span style="color:black">otherwise</span></span> = <span style="font-style:italic"><span style="color:blue">b</span></span>:<span style="font-style:italic"><span style="color:#007F00">delete</span></span> <span style="font-style:italic"><span style="color:blue">a</span></span> <span style="font-style:italic"><span style="color:blue">x</span></span></td></tr>
</table></td></tr>
</table>
</div>
<!--TOC subsubsection id=sec22 Versão imperativa-->
<h4 id="sec22" class="subsubsection">2.1.3.2  Versão imperativa</h4><!--SEC END --><p>A versão imperativa de <code><span style="font-weight:bold"><span style="color:black">delete</span></span></code>, apresentada a seguir, não cria uma nova lista: usa um ponteiro &#X2013; <code><span style="font-style:italic"><span style="color:blue">prev</span></span></code> &#X2013; para percorrer a lista até encontrar o elemento a ser removido e, quando este é encontrado, modifica a estrutura de encadeamento da lista, removendo este elemento. </p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >

<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-style:italic"><span style="color:#007F00">delete</span></span> (<span style="font-style:italic"><span style="color:blue">a</span></span>, <span style="font-style:italic"><span style="color:blue">l</span></span>)
   <span style="font-weight:bold"><span style="color:black">struct</span></span> <span style="font-style:italic"><span style="color:blue">ListaDeInteiros</span></span> *<span style="font-style:italic"><span style="color:blue">prev</span></span> = <span style="font-style:italic"><span style="color:blue">NULL</span></span>;
   *<span style="font-style:italic"><span style="color:blue">p</span></span> = <span style="font-style:italic"><span style="color:blue">l</span></span>
   <span style="font-weight:bold"><span style="color:black">while</span></span> (<span style="font-style:italic"><span style="color:blue">p</span></span> != <span style="font-style:italic"><span style="color:blue">NULL</span></span> &amp;&amp; <span style="font-style:italic"><span style="color:blue">p</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">elem</span></span> != <span style="font-style:italic"><span style="color:blue">a</span></span>)
      <span style="font-style:italic"><span style="color:blue">prev</span></span> = <span style="font-style:italic"><span style="color:blue">p</span></span>
      <span style="font-style:italic"><span style="color:blue">p</span></span> = <span style="font-style:italic"><span style="color:blue">p</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">r</span></span>
      <span style="font-weight:bold"><span style="color:black">if</span></span> (<span style="font-style:italic"><span style="color:blue">prev</span></span> == <span style="font-style:italic"><span style="color:blue">NULL</span></span>)
         <span style="font-weight:bold"><span style="color:black">return</span></span> <span style="font-style:italic"><span style="color:blue">l</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">r</span></span>
      <span style="font-weight:bold"><span style="color:black">else</span></span> { <span style="font-style:italic"><span style="color:blue">prev</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">r</span></span> = <span style="font-style:italic"><span style="color:blue">p</span></span>-&gt;<span style="font-style:italic"><span style="color:blue">r</span></span>; <span style="font-weight:bold"><span style="color:black">return</span></span> <span style="font-style:italic"><span style="color:blue">l</span></span> }</td></tr>
</table></td></tr>
</table>
</div>
<!--TOC subsection id=sec23 Lista duplamente encadeada-->
<h3 id="sec23" class="subsection">2.1.4  Lista duplamente encadeada</h3><!--SEC END --><p>
<a id="lista-duplamente-encadeada"></a></p><p>&#X2026;&#X2026;.....</p>
<!--TOC subsection id=sec24 Pilha-->
<h3 id="sec24" class="subsection">2.1.5  Pilha</h3><!--SEC END --><p>
<a id="pilha"></a></p><p>Uma estrutura de dados <code><span style="font-style:italic"><span style="color:blue">Pilha</span></span></code> caracteriza-se pelo fato de que as operações de inserção, acesso e remoção de elementos são feitas em apenas
um de seus lados (ou extremidades). Essa política de uso é comumente chamada LIFO (do inglês, <em>last-in first-out</em>: o último a ser inserido é o primeiro a ser removido da pilha. A implementação de uma <code><span style="font-style:italic"><span style="color:blue">Pilha</span></span></code> inclui as com as operações: i) criar pilha vazia, ii) empilhar elemento, iii) desempilhar elemento, iv) obter elemento do topo da pilha, e v) testar se pilha está vazia. </p>
<!--TOC subsubsection id=sec25 Versão funcional-->
<h4 id="sec25" class="subsubsection">2.1.5.1  Versão funcional</h4><!--SEC END --><p>
<a id="hevea_default33"></a>
Em <span style="font-family:monospace">Haskell</span>, a implementação de <code><span style="font-style:italic"><span style="color:blue">Pilha</span></span></code> é obtida diretamente das operações definidas sobre listas, isto é:</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >

<table class="lstframe" style="padding:1ex;background-color:#BCD3E5;"><tr><td class="myclisting"><span style="font-style:italic"><span style="color:#007F00">vazia</span></span> = []
<span style="font-style:italic"><span style="color:#007F00">empilhar</span></span> = (:)
<span style="font-style:italic"><span style="color:#007F00">desempilhar</span></span> (_:<span style="font-style:italic"><span style="color:blue">x</span></span>) = <span style="font-style:italic"><span style="color:blue">x</span></span>
<span style="font-style:italic"><span style="color:#007F00">topo</span></span> (<span style="font-style:italic"><span style="color:blue">a</span></span>:_) = <span style="font-style:italic"><span style="color:blue">a</span></span>
<span style="font-style:italic"><span style="color:#007F00">estaVazia</span></span> = <span style="font-weight:bold"><span style="color:black">null</span></span></td></tr>
</table></td></tr>
</table>
</div><p>Em geral, vamos procurar simplificar o código de nossos programas,
não tratando casos de erro, na maioria das vezes, por motivos didáticos. Entretanto, em programas completos não podemos esquecer de tratar todos os casos possíveis para os dados de entrada. Um módulo em Haskell que trata
todos esses casos possíveis para os dados de entrada das operações
acima é mostrado na Figura <a href="#fig-Pilha">??</a>.</p><p>O módulo <code><span style="font-style:italic"><span style="color:blue">Pilha</span></span></code> implementa o que é chamado em computação de um <em>tipo abstrato de dados</em>, que é um tipo com operações de criação,
modificação e consulta sobre valores desse tipo. Por exemplo, <code><span style="font-style:italic"><span style="color:blue">vazia</span></span></code> é uma operação de criação (nesse caso, a única);
<code><span style="font-style:italic"><span style="color:blue">empilhar</span></span></code> e <code><span style="font-style:italic"><span style="color:blue">desempilhar</span></span></code> são operações de modificação; <code><span style="font-style:italic"><span style="color:blue">topo</span></span></code> e <code><span style="font-style:italic"><span style="color:blue">estaVazia</span></span></code> são operações de consulta. </p><p>Em uma definição de um tipo abstrato de dados, a definição de tipo e das operações (para criação, modificação e consulta) sobre valores
do tipo devem ser contidas em um mesmo trecho de programa (em geral,
um módulo), e a representação usada não é &#X201C;visível&#X201D; para quem usa valores do tipo. Ou seja, um tipo abstrato é constituído de um tipo, munido de um conjunto de operações sobre valores desse tipo. Qualquer outra operação sobre valores do tipo apenas pode ser implementada por meio dessas operações previamente definidas.</p><p>Para definir um tipo abstrato <code><span style="font-style:italic"><span style="color:blue">Pilha</span></span></code>, em <span style="font-family:monospace">Haskell</span>, usamos uma definição de um novo tipo, introduzida pela palavra-chave <code><span style="font-weight:bold"><span style="color:black">newtype</span></span></code>. O tipo <code><span style="font-style:italic"><span style="color:blue">Pilha</span></span></code> possui um único construtor de valores <code><span style="font-style:italic"><span style="color:blue">mkPilha</span></span></code> (de mesmo nome do construtor de tipo). Esse mecanismo é usado para ocultar a representação do tipo abstrato: o construtor de que não é exportado pelo módulo em que o tipo é definido: o construtor de valores <code><span style="font-style:italic"><span style="color:blue">mkPilha</span></span></code> não é exportado, apenas o construtor de tipos <code><span style="font-style:italic"><span style="color:blue">Pilha</span></span></code>. Para melhor legibilidade, definimos também o tipo de cada uma das funções. Veja Figura <a href="#fig-Pilha">??</a>.
</p><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<hr style="height:2"><blockquote class="quote"><em>Este documento foi traduzido de L<sup>A</sup>T<sub>E</sub>X por
</em><a href="http://hevea.inria.fr/index.html"><em>H</em><em><span style="font-size:small"><sup>E</sup></span></em><em>V</em><em><span style="font-size:small"><sup>E</sup></span></em><em>A</em></a><em>.</em></blockquote></body>
</html>
