% !TEX encoding = ISO-8859-1
\section{Pesquisa binária}
\label{sec:pesquisa-binaria}

O algoritmo de pesquisa binária é um algoritmo bastante simples e
eficiente. Consiste em pesquisar um arranjo ordenado, baseando-se na
comparação da chave $v$ de pesquisa (i.e.~valor pesquisado) com um
valor $v'$ na metade do arranjo e repetição dessa operação, se
$v\not=v'$, considerando apenas a metade à esquerda do arranjo se $v <
v'$, e à direita de $v > v'$. Veja Figura abaixo.

....

Versões recursivas e iterativas são apresentadas, em Haskell e em
pseudo-código, nas seções \ref{sec:pesquisa-binaria-fun} e
\ref{sec:pesquisa-binaria-imp} a seguir. 

A pesquisa binária é às vezes apresentada como o melhor exemplo da
técnica de divisão (comumente chamada de ``dividir-para-conquistar'',
em inglês {\em divide-and-conquer\/}). No entanto, isso não está de
acordo com a classificação que apresentamos, segundo a qual a técnica
de divisão divide a entrada do algoritmo em duas ou mais sub-partes,
que então são solucionadas, sendo os resultados obtidos usados para
obter uma solução do problema original. Esse não é o caso da pesquisa
binária, no qual se escolhe uma única sub-parte da entrada do problema
original para ser considerada. Consideramos, assim, que a pesquisa
binária é um exemplo de uso da técnica de decremento, de fato
decremento por um fator constante (e igual a 2, ou seja, decremento
por divisão à metade). Esta observação foi feita por Levitin
\cite{Levitin:2007:Introd-Design-Analysis-Alg}.

\subsection{Versão funcional}
\label{sec:pesquisa-binaria-fun}

A versão recursiva é mostrada a seguir.

\begin{center}
\begin{tabular}{l}
\begin{hask}{pesqBin'}{\decremento}
import Data.Array ((!),bounds)

pesqBin v a = pesqBin' (bounds a)
 where 
   pesqBin' (i,j)
      | j < i      = Nothing 
      | comp == LT = pesqBin' (i,meio-1)
      | comp == GT = pesqBin' (meio+1,j)
      | otherwise = Just meio
      where
        meio = i + div (j-i) 2
        v'   = a ! meio
        comp = compare v v'
\end{hask}
\end{tabular}
\end{center}

Uma pequena otimização é que é realizada uma única comparação, usando
\inh{compare v v'}, que retorna se \inh{v} é menor (\inh{LT}, as
iniciais de {\em \underline{l}ess \underline{t}han\/}), maior
(\inh{GT}, as iniciais de {\em \underline{g}reater
  \underline{t}han\/}) ou igual a \inh{v'} (não é preciso testar por
exemplo se \inh{h} é menor que \inh{v'} e, caso negativo, se é maior).

Obtemos a seguinte relação de recorrência para a complexidade de tempo
de \inh{pesqBin} no pior caso:

  \[ \begin{array}{ll}
       T(0) = 0                   & \\
       T(n) = T(\lfloor{n/2}) + k & (n>0)
     \end{array}
  \]
onde $k$ é uma constante que indica a complexidade de tempo das
comparações \inh{(<)}, \inh{compare} e \inh{(==)}, a indexação
(\inh{(!)}) e as operações aritméticas \inh{(+)}, \inh{(-)} e
\inh{div} (para definição de $\lfloor$, veja exercício resolvido
\ref{ex:lfloor-rfloor-def} na seção
\ref{sec:exs-resolvidos-complexidade}).

Uma solução dessa relação de recorrência foi apresentada na seção
\ref{sec:num-digs-fun}, onde obtivemos:

   \[ T(n) \asymp lg n \]

\subsection{Versão imperativa}
\label{sec:pesquisa-binaria-imp} 

A versão imperativa é mostrada a seguir, onde supomos que o arranjo
(\ina{A}) tem \ina{n} elementos (indexados de \ina{0} a \ina{n}-1).

\begin{center}
\begin{tabular}{l}
\begin{alg}{pesqBin}{\decremento}
pesqBin (chave, A, n) 
  esq = 0
  dir = n-1
  while esq <= dir
    meio = (esq + dir) / 2
    v = arr[meio]
    if (chave == v) return meio else
    if (chave < v) dir = meio - 1 
    else esq = meio + 1
  return -1
\end{alg}
\end{tabular}
\end{center}

Como após cada iteração, o tamanho do arranjo a ser considerado é
igual a $\lfloor{m/2}$ do tamanho $m$ anterior à iteração, a
complexidade de tempo de \ina{pesqBin} pode ser expressa pela mesma
relação de recorrência do caso recursivo:

  \[ \begin{array}{ll}
       T(0) = k_0                 & \\
       T(n) = T(\lfloor(n/2)) + k & (n>0)  
     \end{array}
  \]
onde $k_0$ é uma constante que indica a complexidade das atribuições a
\ina{esq,dir} e da comparação \ina{esq <= dir}, e $k$ é uma constante
que indica a complexidade de tempo da comparação \inh{esq <= dir} e da
execução dos comandos internos ao comando \ina{while} (a definição de
$\lfloor$ pode ser vista no exercício resolvido
\ref{ex:lfloor-rfloor-def}, seção
\ref{sec:exs-resolvidos-complexidade}).

Um outro modo de expressar $T(n)$ considera que o número de vezes que
a iteração é repetida é igual a $\lfloor{lg \ina{n}}$, e portanto:

   \[ T(n) = k \times \lfloor{lg \ina{n}} + k_0 \]
ou seja:

   \[ T(n) \asymp lg n \]

