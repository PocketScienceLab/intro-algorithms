% !TEX encoding = ISO-8859-1
\chapter{Técnicas de Projeto de Algoritmos}
\label{ch:tecnicas-de-projeto-de-algoritmos}

Consideramos as seguintes técnicas de projeto de algoritmos (seguindo
as ideias de Levitin \cite{Levitin:2007:Introd-Design-Analysis-Alg}):

\begin{description}

\item[Divisão] (em inglês, chamada de {\em divide-and-conquer\/}): é
  baseada em dividir a instância do problema em duas ou mais partes
  menores, resolver essas duas ou mais sub-instâncias e combinar os
  resultados obtidos para solução do problema original.

  Algoritmos de caminhamento em árvores binárias (pre-ordem, pos-ordem
  e visita-no-meio (em inglês, {\em in-order\/}) são exemplos de uso
  da técnica de divisão (veja exercício resolvido
  \ref{ex:caminhamento-em-arvores-binarias}). Outros exemplos são {\em
    quickSort\/} (seção \ref{sec:quickSort}) e {\em mergeSort\/} (seção
  \ref{sec:mergeSort}). 

\item[Decremento] (em inglês, chamada de {\em decrease-and-conquer\/}):
  é baseada em passar da instância original para uma instância menor
  ou reduzir o tamanho da entrada do problema para solução da
  instância original. O decréscimo é tipicamente de um valor ou por um
  fator constante no tamanho da entrada, mas pode também ser um
  decréscimo de um valor ou por um fator variável. Note que o
  decremento por um fator constante não é caracterizado como divisão
  (seguindo \cite{Levitin:2007:Introd-Design-Analysis-Alg}): a
  diferença está em que decrementar não origina duas ou mais
  sub-instâncias (apenas decrementa o tamanho da entrada).

  A vasta maioria dos algoritmos apresentados neste livro usam a
  técnica de decremento. Veja por exemplo \inh{maiorElem} (seção
  \ref{sec:maior-elemento}), \inh{elem} (seção
  \ref{sec:pesquisa-em-lista}), \inh{verifUnicidade} (seção
  \ref{sec:unicidade}), ordenação por inserção (seção
  \ref{sec:insertion-sort-func}), funções \inh{sorted}, \inh{perm} e
  \inh{delete} (seção \ref{sec:insertion-sort-func}), multiplicação de
  matrizes (seção \ref{sec:multiplicacao-de-matrizes}), função
  \inh{fib} (seção \ref{sec:numeros-de-fibonacci}).

\item[Uso-da-Definição] (também chamada de {\em força bruta\/}):
  baseada em uso direto da especificação do problema e das definições
  dos conceitos envolvidos na especificação do problema e, além disso,
  quando a técnica não se encaixa em alguma das demais técnicas acima.

  Exemplos ....

\end{description}

Vamos chamar cada técnica do conjunto de técnicas acima de TPA. Todo
programa apresentado neste livro é classificado segundo uma, e apenas
uma, TPA. O objetivo é o de motivar e ajudar no processo de
desenvolvimento do raciocínio usado na elaboração de algoritmos. É
instrutivo não apenas entender a classificação e procurar classificar
algoritmos segundo uma TPA, mas também considerar a existência ou não
de outros algoritmos, elaborados segundo outra TPA. Isso ajuda a
organizar o raciocínio, e pode contribuir para o entendimento sobre
algoritmos existentes e para o aumento da motivação no estudo de novos
algoritmos.

Para espeficicar a classificação de algoritmo, implementado por função
com nome salientado no texto em cor \textcolor{Mahogany}{mogno}
(mogno), usamos cores de fundo, como a seguir:

  \begin{description}
    \item[{\colorbox{\divisao}{divisão}}] 
    \item[{\colorbox{\decremento}{decremento}}]
    \item[{\colorbox{\definicao}{definição}}]
  \end{description}

Quando não se trata de um algoritmo, ou quando são incluídas várias
funções e não está se considerando a análise da eficiência de um
algoritmo, é usado fundo branco.

As técnicas de projeto de algoritmos abaixo, tradicionalmente vistas
como principais, são consideradas como sub-classificações, por não
constituir base para classificação de algoritmos em geral:

  \begin{enumerate}

     \item gananciosa (em inglês, {\em greedy\/}) --- para problemas
       de {\em otimização\/}, baseada na escolha de {\em ótimo\/}
       local, i.e.~baseada em fazer melhor escolha na fase ou instante
       corrente.

       Exemplos...

     \item programação dinâmica --- ....

     \item busca exaustiva --- baseada na tentativa de todos os
       possíveis valores que possam levar a uma solução, até que uma
       solução seja encontrada. É um caso de uso-da-definição.

       A limitação mais importante da busca exaustiva é sua
       ineficiência. Em geral, o número de possíveis valores que podem
       levar a uma solução cresce muito rapidamente
       (e.g.~exponencialmente) com o crescimento do tamanho da
       entrada.

       Exemplos ....

     \item retrocedimento (em inglês, {\em backtracking\/}) ---
       baseada na tentativa de realizar escolhas, dentre opções
       existentes, para construção da solução passo a passo e
       retroceder na escolha feita em um passo se esta escolha não
       puder ser usada para gerar uma solução.

       No pior caso, retrocedimento pode acabar gerando todas as
       soluções possíveis, como no caso da busca exaustiva, mas não é
       comum isso ocorrer. 

       É instrutivo visualizar a técnica de retrocesso como um
       processo de construir uma árvore que mostra as decisões tomadas
       a cada passo. A raiz da árvore corresponde ao estado inicial
       antes do primeiro passo, e cada nó da árvore contém sub-árvores
       com raízes que correspondem a estados que caracterizam a
       decisão tomada no passo seguinte.

       Por exemplo, a árvore abaixo descreve a técnica de
       retrocedimento aplicada ao problema de colocar 4 rainhas em um
       tabuleiro 4x4 sem que haja uma rainha atacando outra (veja
       exercício \ref{rainhas-nao-se-atacando}.

       ......

  \end{enumerate}

%    \item[transformação]
%       \begin{description}
%         \item[{\colorbox{\simplificacao}{simplificação}}]
%         \item[{\colorbox{\mudancaRep}{mudança de representação}}]
%         \item[{\colorbox{\preProcess}{pré-processamento}}]
%      \end{description}

Levitin considera também a técnica de transformação (em inglês,
chamada de {\em transform-and-conquer\/}), baseada em transformar a
instância do problema original em outra instância do mesmo ou de outro
problema (com o mesmo tamanho da instância original), e em usar ou
adaptar o resultado para solução do problema original.  A
transformação para uma instância do mesmo problema pode envolver {\em
  simplificação\/} ou {\em mudança de representação\/} ou {\em
  pré-processamento\/} da entrada.

A simplificação não envolve mudança de representação da entrada: usa a
mesma representação original, transformando a entrada para que ela
tenha alguma propriedade que torna a solução do problema mais fácil ou
mais eficiente (por exemplo, ordenando os dados de entrada). O
pré-processamento é caracterizado pela existência de um ou mais passos
adicionais sobre os dados de entrada, para obtenção de dados extras,
novamente para tornar a solução do problema mais fácil ou mais
eficiente.

Consideramos que a técnica de transformação está em um outro nível,
acima das TPAs. Ela constitui uma técnica de projeto usada para
solução de um problema mas não uma classificação de técnica de projeto
usada para um algoritmo particular, como acontece nos casos das
TPAs. Consideramos o projeto de algoritmos como tendo duas fases: a
primeira consiste em decidir se uma transformação vai ser usada ou
não. A segunda fase consiste do projeto do algoritmo propriamente dito
(usando uma das TPAs). Na primeira fase, se a técnica de transformação
for usada, a transformação precisa ser especificada e implementada,
ela própria, por meio de um algoritmo, o qual deve ser classificado de
acordo com alguma TPA.

\section{Exercícios Resolvidos}

Escreva programa para solução de cada problema enunciado a seguir e
indique a TPA usada.

\begin{enumerate}

\item \label{ex:caminhamento-em-arvores-binarias} Considere o problema
  de caminhamento em árvores (aplicado em geral a grafos) chamados de
  {\em busca em profundidade\/} e {\em busca em largura\/}.

  A busca em profundidade ...

  A busca em largura ...

  Escreva algoritmos para caminhamento em árvores binárias, árvores
  com qualquer número de filhos e árvores que usam a {\em
    representação com primogênito-irmão-e-pai} (e indique a técnica
  usada em cada algoritmo).

\item Problema da Celebridade: uma celebridade de um grupo de $n$
  pessoas é uma pessoa que não conhece ninguém do grupo mas é
  conhecida por todas as pessoas do grupo.  O problema consiste em,
  dados: i) $n$, ii) uma lista de pessoas, e iii) uma tabela que
  indica, para cada par de pessoas $(a,b)$ da lista, se $a$ conhece
  $b$, identificar uma celebridade do grupo de pessoas (supondo, por
  simplicidade, que uma celebridade de fato existe).

  {\bf Solução}: O algoritmo que soluciona o problema usa a técnica de
  decremento. Se só há duas ou mais pessoas quaisquer $a$ e $b$ na
  lista, o algoritmo verifica se $a$ conhece $b$; em caso positivo,
  $a$ é removido da lista (celebridades não conhecem ninguém) e, em
  caso negativo, $b$ é removido (celebridades são conhecidas por
  todos). Se há só uma pessoa na lista, essa pessoa é uma celebridade.
 
{\bf Versão funcional}: Em Haskell, usamos abaixo um mapeamento, em
vez de um arranjo, para definir quando duas pessoas se conhecem ou
não.

\HRule
{\em Nota\/}: 

Um valor de tipo \inh{Map k a}, para tipos \inh{k} e \inh{a} quaisquer
com a única condição que \inh{k} seja da classe \inh{Ord} (sobre
classes de tipos em Haskell, veja seção \ref{sec:Classes-de-tipos}),
associa valores de tipo \inh{k}, chamados de {\em chaves}, a valores
de tipo \inh{a} (de modo semelhante a arranjos e funções). O conjunto
de chaves (de um valor \inh{m} de tipo \inh{Map k a}) é chamado de
{\em domínio\/} de \inh{m}. Internamente, um valor de tipo \inh{Map k
  a} é implementado como uma árvore binária balanceada.

No programa abaixo, usamos valores \inh{m} de tipo \inh{Map
  (Pessoa,Pessoa) Bool} para indicar se duas pessoas \inh{(a,b)} se
conhecem ou não: em caso positivo \inh{m ! (a,b)} é igual a
\inh{True}. Em caso negativo, o par \inh{(a,b)} não faz parte do
domínio de \inh{m} (ou seja, o par \inh{(a,b)} não foi inserido como
uma chave de \inh{m}) e nesse caso a avaliação de \inh{m ! (a,b)}
resulta em um erro. Usamos por isso \inh{findWithDefault False (a,b)
  m}, que retorna \inh{False} se \inh{(a,b)} não pertence ao domínio
de \inh{m} (\inh{findWithDefault v k m} retorna \inh{m!k} --- o valor
associado à chave \inh{k} em \inh{m} --- se \inh{k} pertence ao
domínio de \inh{m}, caso contrário retorna o valor \inh{v}).

O mapeamento que indica se pares de pessoas se conhecem pode ser
criado com a função \inh{conheceM0}, que cria um mapeamento a partir
de uma lista de pares \inh{((a,b),True)}, que indica que a pessoa
\inh{a} conhece a pessoa \inh{b}. 

\HRule

\begin{center}
\begin{tabular}{l}
\begin{hask}{celebridade}{\decremento}

module Celebridade where

import Data.Map (Map, findWithDefault, fromList)

type NumPessoas = Integer
type Pessoa     = Integer

type ConheceM   = Map (Pessoa,Pessoa) Bool
-- For m::ConheceM, findWithDefault False (a,b) m = True sse (a conhece b).

conheceM0 :: [(Pessoa,Pessoa)] -> ConheceM
conheceM0 x = fromList [(p,True) | p <- x]

celebridade :: NumPessoas -> [Pessoa] -> ConheceM -> Pessoa
-- Pre: celebridade n x m implica n = length x
celebridade n (a:b:r) m           
  | findWithDefault False (a,b) m = celebridade (n-1) (b:r) m -- a não é celeb. (celeb. não conhece ninguém)
  | otherwise                     = celebridade (n-1) (a:r) m -- b não é celeb. (todos conhecem celeb.)
celebridade _ [a]     _           = a -- n==1

\end{hask}
\end{tabular}
\end{center}

{\bf Versão imperativa}: \ldots

....

\item \label{rainhas-nao-se-atacando} ....

\end{enumerate}

\section{Exercícios}

