%!TEX encoding = ISO-8859-1
\chapter{Estruturas de Dados Básicas}
\label{ch:estruturas-de-dados-basicas}

Este capítulo aborda listas e árvores, suas representações em um computador e
operações básicas sobre essas estruturas de dados.

\section{Listas}
\label{sec:listas}

Uma lista é uma estrutura de dados comumente usada em computação e
pode ser definida recursivamente como a seguir.  Uma lista de
elementos de determinado tipo \inh{t} é ou i) {\em vazia} ou ii)
constituída de um elemento de tipo \inh{t} e um uma lista de elementos
do mesmo tipo \inh{t} (denominada {\em cauda} ou resto da lista).

Em uma linguagem como Haskell, que provê suporte à definição de tipos
de dados recursivos, o tipo lista pode ser definido como:

\begin{center}
\begin{tabular}{l}
\begin{hask}{List,Nil,Cons}{White}
data List a = Nil | Cons a (List a)
\end{hask}
\end{tabular}
\end{center}

O tipo de dado \inh{List a}\ é um tipo recursivo, sendo \inh{Nil} e
\inh{Cons} os construtores de valores desse tipo. Além disso,
\inh{List a}\ é um tipo {\em polimórfico}: a variável de tipo \inh{a}
pode ser instanciada para um tipo \inh{t} qualquer, permitindo assim a
definição de listas com elementos de desse tipo \inh{t}. Por exemplo,
\inh{(Cons 1 (Cons 2 (Cons 3 Nil)))} é uma lista de tipo \inh{List
  Int} e \inh{(Cons True (Cons False Nil))} tem tipo \inh{List Bool}.

A linguagem Haskell provê uma notação especial para a criação de
valores de tipo lista: \inh{[]} é usado em lugar de \inh{Nil}, e o
construtor infixado \inh{(:)}, associativo à direita, em lugar de
\inh{Cons}. Por exemplo, a lista \inh{Cons 1 (Cons 2 (Cons 3 Nil))}
seria representada como \inh{(1:2:3:[])}.  Além disso, uma lista pode
ser representada simplesmente escrevendo-se os seus elementos da lista
entre colchetes, separados por vírgulas. Ou seja, a lista
\inh{\inh{(1:2:3:[]}} pode ser escrita, mais simplesmente, como
\inh{[1,2,3]}.

Em linguagens como \C, uma lista pode ser representada por meio de
{\em registros} (também chamados de "estruturas", em \C) e {\em
  ponteiros\/} (ou apontadores), tal como ilustrado no exemplo a
seguir, que define uma lista de elementos de tipo
\ina{int}. Linguagens como \C, que não provêm suporte para
polimorfismo, requerem a definição de tipos lista distintos para cada
tipo particular de elementos.

\begin{center}
\begin{tabular}{l}
\begin{alg}{ListaDeInteiros}{White}
struct ListaDeInteiros
   int elem; 
   struct ListaDeInteiros *r;
\end{alg}
\end{tabular}
\end{center}

Uma definição de registro, em \C, é introduzida pela palavra-chave
\ina{struct}, seguida do nome do registro -- neste caso,
\ina{ListaDeInteiros}. O registro possui dois campos: um campo de tipo
\ina{int} e nome \ina{elem}, e um campo de nome \ina{r}, que é um
ponteiro para valores do próprio tipo \ina{ListaDeInteiros}.
 
A manipulação de valores de tipo lista em \C\ é bem mais trabalhosa. A
falta de suporte para definição e uso de tipos recursivos e
polimórficos torna a programação mais difícil e demorada e o código
menos legível e mais sujeito a repetições e a ocorrências de
erros. Por exemplo, para criar um valor de tipo \ina{ListaDeInteiros},
com os elementos \inh{1,2,3}, é necessário código como o seguinte:
\index{\ina{ListaDeInteiros}}

\begin{center}
\begin{tabular}{l}
\begin{alg}{ListaDeInteiros}{White}
struct ListaDeInteiros *p §$\from$§ malloc(sizeof(struct ListaDeInteiros))
   p->elem §$\from$§ 1;       p->r §$\from$§ malloc(sizeof(struct ListaDeInteiros))
   p->r->elem §$\from$§ 2;    p->r->r §$\from$§ malloc(sizeof(struct ListaDeInteiros))
   p->r->r->elem §$\from$§ 3; p->r->r->r §$\from$§ NULL
\end{alg}
\end{tabular}
\end{center}

\ina{sizeof} retorna o número de unidades de memória necessário para
variáveis do tipo especificado. \ina{malloc} aloca o número de
unidades de memória especificado na área dinâmica do processo corrente
(em inglês, a área dinâmica de memória de um processo é comumente
chamada de {\em heap\/}).

Em \Haskell, o acesso a um valor \inh{v}, em uma lista \inh{x}, requer
acesso a todos os elementos anteriores a \inh{v} em \inh{x}. De fato,
a representação interna de listas definidas em \Haskell é feita por
meio de ponteiros, mas a manipulação de ponteiros é gerada
automaticamente pelo compilador da linguagem, de acordo com o código
do programa, em vez de ser feita diretamente pelo programador.

Uma maneira alternativa de representar listas é por meio de {\em
  arranjos}, especialmente em uma linguagem (como \C) que não provê
suporte a manipulação de valores de estruturas de dados
recursivas. Utilizando essa forma de representação, a lista fica
limitada a um número máximo de elementos, já que a defição de uma
arranjo requer que o número de elementos do mesmo seja especificado a
priori.

\subsection{Pesquisa}
\label{sec:pesquisa-em-lista}

Em computação, {\em pesquisar\/} em geral significa determinar se um
dado elemento está presente ou não em uma estrutura de dados. As
subseções seguintes tratam de operações de pesquisa, inserção e
remoção de elementos de listas, de acordo com a forma com que listas
são representadas.

Em ambos os casos apresentados abaixo, a pesquisa em uma lista de $n$
elementos tem complexidade $O(n)$ no pior caso, pois envolve,
possivelmente, comparação com cada elemento da lista.

\subsubsection{Versão funcional}

A função \inh{elem}, que determina se um dado valor é elemento de uma
lista dada, pode ser definida como a seguir: \index{\inh{elem}}

\begin{center}
\begin{tabular}{l}
\begin{hask}{elem}{\decremento}
elem :: Eq a => a -> a -> Bool
elem a []    = False
elem a (b:x) = (a == b) || elem a x
\end{hask}
\end{tabular}
\end{center}

O tipo de \inh{elem}, em \Haskell, é um tipo {\em polimórfico
  restrito\/}: a restrição ({\em constraint\/}) (\inh{Eq a}) indica
que a variável de tipo \inh{a} não pode ser instanciada para qualquer
tipo, mas apenas para um tipo que é membro da classe de tipos
\inh{Eq}, ou seja, no caso, apenas para um tipo para o qual exista
definida uma operação de igualdade \inh{(==)}, para valores desse
tipo. É um erro de tipo chamar a função \inh{elem} com um argumento de
um tipo para o qual não é definida comparação de igualdade.

\HRule
{\em Nota\/}: 

A função \inh{elem}, de fato, faz parte do módulo \Prelude, importado
automaticamente por todos os módulos de programas \Haskell, sem
necessidade de comando ou cláusula explícita de importação. A
definição de \inh{elem} no \Prelude\ é diferente da apresentada acima,
e usa outras funções também definidas no \Prelude, como \inh{map} e
\inh{foldr}, que são ferramentas importantes para definição de outras
funções em Haskell. A definição de \inh{elem} contida no \Prelude\ é
apresentada a seguir:

\begin{center}
\begin{tabular}{l}
\begin{hask}{foldr,map,and,or,any,all,elem}{\decremento}

foldr  :: (a -> b -> b) -> b -> [a] -> b
foldr f z []    =  z
foldr f z (a:x) =  f a (foldr f z x) 

map :: (a -> b) -> [a] -> [b]
map _  []   = []
map f (a:x) = f a : map f x 

and, or :: [Bool] -> Bool
and =  foldr (&&) True
or  =  foldr (||) False 

any, all :: (a -> Bool) -> [a] -> Bool
any p =  or . map p
all p =  and . map p 

elem :: (Eq a) => a -> [a] -> Bool
elem a = any (== a)
\end{hask}
\end{tabular}
\end{center}

\HRule

\subsubsection{Versão imperativa}
\label{pesquisa-sequencial-em-arranjo-versao-imp}

A versão imperativa de \ina{elem} definida a seguir recebe como
argumento o valor a ser pesquisado, denotado pelo parâmetro \ina{a},
juntamente com um apontador para uma lista (de tipo
\ina{ListaDeInteiros}), denotado pelo parâmetro \ina{l}. O algoritmo
retorna retorna um apontador para o elemento da lista \ina{l} que é
igual a \ina{a}, caso o argumento esteja presente na lista, e retorna
\ina{NULL} em caso contrário.  \index{\ina{elem}}

\begin{center}
\begin{tabular}{l}
\begin{alg}{elem}{\decremento}
elem (a, l) 
   while ((l != NULL) && (l->elem != a)) l §$\from$§ l->r
   return l
\end{alg}
\end{tabular}
\end{center}

Em uma pesquisa sequencial em um arranjo, um valor igual ao que está
sendo pesquisado pode ser armazenado no fim do arranjo, para evitar o
teste relativo a se a pesquisa chegou ao fim do arranjo. Tal valor é
comumente chamado de {\em sentinela\/}.  O mesmo poderia ser feita com
uma lista, mas nesse caso é mais apropriado usar também um apontador
para o último elemento da lista (ou uma lista duplamente encadeada,
como no exercício resolvido \ref{....}), para evitar ter que percorrer
toda a lista para armazenar a sentinela. Um programa com uso de
sentinela para pesquisa em um arranjo indexado de 0 a \ina{n}-1 é
mostrado a seguir, onde o resultado é o índice do arranjo, se o valor
pesquisado for encontrado, e -1 caso contrário:

\begin{center}
\begin{tabular}{l}
\begin{alg}{elem}{\decremento}
elem (k, A) 
   A[n-1] §$\from$§ k
   i §$\from$§ 0
   while (A[i] != k) do
    i §$\from$§ i + 1
   return (i < n ? i : −1)
\end{alg}
\end{tabular}
\end{center}

O programa usa uma expressão condicional (em vez do comando
condicional, ou "comando \if"), como em \C: a expressão \ina{e ? e1 :
  e2} denota o mesmo resultado de \ina{e1} ou de \ina{e2} conforme a
avaliação de \ina{e} seja verdadeira ou falsa, respectivamente.

\subsection{Inserção}
\label{sec:insercao-em-lista}

Inserir um elemento no início de uma lista é uma operação de
complexidade $O(1)$.

\subsubsection{Versão funcional}
\label{sec:insercao-inicio-de-lista-versao-func}

A inserção de um elemento no início da lista é feita simplesmente, por
meio do construtor de lista \inh{(:)}, ou seja: \index{\inh{insert}}

\begin{center}
\begin{hask}{insert}{\definicao}
insert = (:)
\end{hask}
\end{center}

\subsubsection{Versão imperativa}
\label{sec:insercao-inicio-de-lista-versao-imp}

Na versão imperativa, é alocado um novo registro, de tipo
\ina{ListaDeInteiros}, para armazenar o novo valor a ser inserido na
lista, sendo retornada a lista resultante dessa operação.
\index{\ina{insert}}

\begin{center}
\begin{tabular}{l}
\begin{alg}{insert}{\definicao}
insert (a, l)
   p = malloc(sizeof(struct ListaDeInteiros))
   p->elem = a
   p->r = l
   return p
\end{alg}
\end{tabular}
\end{center}

\subsection{Remoção}
\label{sec:remocao-de-lista}

Remover um elemento de uma lista é uma operação de complexidade $O(n)$
no pior caso, pois é necessário procurar o elemento a ser removido.

A Seção \ref{sec:lista-duplamente-encadeada} redefine o tipo de lista
encadeada para uma versão de listas duplamente encadeadas, e reescreve
as funções \ina{elem} e \ina{insert}, para definir \ina{delete} por meio de uma
chamada à função \ina{elem}, seguida de chamada a \ina{insert}.

\subsubsection{Versão funcional}

A versão funcional cria uma nova lista, que não tem o elemento
passado como parâmetro:
\index{\inh{delete}}

\begin{center}
\begin{tabular}{l}
\begin{hask}{delete}{\decremento}
delete :: Eq a => a -> [a] -> [a]
delete §{\tt \_}§ [] = []
delete a (b:x)
   | a == b    = x
   | otherwise = b:delete a x
\end{hask}
\end{tabular}
\end{center}

\subsubsection{Versão imperativa}

A versão imperativa de \ina{delete}, apresentada a seguir, não cria
uma nova lista: usa um ponteiro -- \ina{prev} -- para percorrer a
lista até encontrar o elemento a ser removido e, quando este é
encontrado, modifica a estrutura de encadeamento da lista, removendo
este elemento.

\begin{center}
\begin{tabular}{l}
\begin{alg}{delete}{\decremento}
delete (a, l) 
   struct ListaDeInteiros *prev = NULL;  
   *p = l
   while (p != NULL && p->elem != a)
      prev = p
      p = p->r
      if (prev == NULL) 
         return l->r
      else { prev->r = p->r; return l }
\end{alg}
\end{tabular}
\end{center}
             
\subsection{Pilha}
\label{sec:pilha}
\index{pilha}

Uma estrutura de dados {\em Pilha} caracteriza-se pelo fato de que as
operações de inserção, acesso e remoção de elementos são feitas em
apenas um de seus lados (ou extremidades). Essa política de uso é
comumente chamada LIFO (do inglês, {\em last-in first-out\/}: o último
a ser inserido é o primeiro a ser removido da pilha. Discutimos, a
seguir, a implementação de uma Pilha, com as operações: i) criar pilha
vazia, ii) empilhar elemento, iii) desempilhar elemento, iv) obter
elemento do topo da pilha, e v) testar se pilha está vazia. É fácil
ver que a ordem de complexidade de tempo de cada uma dessas operações
é $O(1)$.

\subsubsection{Versão funcional}
\label{sec:ops-sobre-pilhas-versao-func}

\index{pilha}
Em \Haskell, a implementação de \inh{Pilha} é obtida diretamente das operações definidas sobre listas, isto é:

\begin{center}
\begin{tabular}{l}
\begin{hask}{vazia,empilhar,desempilhar,topo,estaVazia}{\definicao}
vazia = []
empilhar = (:)
desempilhar (§{\tt \_}§:x) = x
topo (a:§{\tt \_}§) = a
estaVazia = null
\end{hask}
\end{tabular}
\end{center}
                  
Em geral, vamos procurar simplificar o código de nossos programas, não
tratando casos de erro, por motivos didáticos. Entretanto, em
programas completos, não podemos esquecer de tratar todos os casos
possíveis para os dados de entrada. O módulo \href{figPilha}{Tipo
  abstrato Pilha}, a seguir, implementa esse tipo abstrato,
considerando todos esses casos possíveis para os dados de entrada das
operações.

O módulo \inh{Pilha} implementa o que é chamado em computação de um
{\em tipo abstrato de dados\/}, que é um tipo com operações de
criação, modificação e consulta sobre valores desse tipo. Por exemplo,
\inh{vazia} é uma operação de criação (nesse caso, a única);
\inh{empilhar} e \inh{desempilhar} são operações de modificação;
\inh{topo} e \inh{estaVazia} são operações de consulta.

Em uma definição de um tipo abstrato de dados, a definição de tipo e
das operações (para criação, modificação e consulta) sobre valores do
tipo devem ser contidas em um mesmo trecho de programa (em geral, um
módulo), e a representação usada não é ``visível'' para quem usa
valores do tipo. Ou seja, um tipo abstrato é constituído de um tipo,
munido de um conjunto de operações sobre valores desse tipo. Qualquer
outra operação sobre valores do tipo apenas pode ser implementada por
meio dessas operações previamente definidas.

Para definir um tipo abstrato \inh{Pilha}, em \Haskell, usamos uma
definição de um novo tipo, introduzida pela palavra-chave
\inh{newtype}. O tipo \inh{Pilha} possui um único construtor de
valores \inh{mkPilha} (de mesmo nome do construtor de tipo). Esse
mecanismo é usado para ocultar a representação do tipo abstrato: o
construtor de que não é exportado pelo módulo em que o tipo é
definido: o construtor de valores \inh{mkPilha} não é exportado,
apenas o construtor de tipos \inh{Pilha}. Para melhor legibilidade,
definimos também o tipo de cada uma das funções. Veja o código a
seguir.  \index{\inh{Pilha}}

\begin{center}
\begin{tabular}{l}
\begin{hask}{Pilha,vazia,empilhar,desempilhar,topo,estaVazia}{\definicao}
caption={Tipo abstrato Pilha},%
label={figPilha}]

module Pilha (Pilha, vazia, empilhar, desempilhar, topo, estaVazia) where
   newtype Pilha a = mkPilha [a] 

   vazia :: Pilha a
   vazia = mkPilha []
   
   empilhar :: a -> Pilha a -> Pilha a
   empilhar e (mkPilha p) = Pilha (e:p)

   desempilhar :: Pilha a -> Pilha a
   desempilhar (mkPilha [])    = error "Função desempilhar chamada com pilha vazia"
   desempilhar (mkPilha (_:p)) = mkPilha p

   topo:: Pilha a -> a
   topo (mkPilha [])    = error "Função topo chamada com pilha vazia"
   topo (mkPilha (e:_)) = e 
  
   estaVazia:: Pilha a -> Bool
   estaVazia (mkPilha p) = null p
\end{hask}
\end{tabular}
\end{center}

\subsubsection{Versão imperativa}
\index{pilha}

Na versão imperativa, consideramos uma \ina{pilha} representada como
um registro com dois campos: \in{topo} e \ina{elems}, sendo
\ina{elems}\ um arranjo de $n$ elementos (indexado de $0$ a {\tt
  $n$-1}), e \ina{topo}\ uma variável inteira, que indica o índice do
último elemento inserido. As operações sobre a \ina{pilha} podem ser
implementadas como a seguir (desconsiderando-se os casos de erro:
desempilhar de uma pilha vazia e empilhar em uma pilha cheia).

\begin{center}
\begin{tabular}{l}
\begin{alg}{vazia,empilhar,desempilhar,topo,estaVazia}{\definicao}
vazia (pilha) { pilha.topo = -1 }

empilhar (e, pilha) 
   with pilha { topo = topo + 1; elems[topo] = e }

desempilhar (pilha) 
   with pilha { topo = topo - 1 }
   
topo (pilha)
   with pilha { return elems[topo] }  
  
estaVazia (pilha) { return pilha.topo == -1 }
\end{alg}
\end{tabular}
\end{center}

O comando \ina{with}, usado no código acima, serve para tornar
visíveis os nomes de campos de um registro: \ina{with r} evita que se
tenha que prefixar os nomes dos campos do registro ina{r} com o nome
do registro.

% (\nome\ pode ser usado em vez de {\tt $r$.\nome}).

\subsection{Fila}
\label{sec:fila}
\index{fila}

Em uma {\em Fila}, a inserção é feita de um lado e a remoção é feita
do lado oposto da estrutura de dados -- política de uso algumas vezes
chamada de FIFO ({\em first-in first-out\/}: o primeiro a ser inserido
é o primeiro a ser removido da fila.

Uma fila, com operações de i) criar fila vazia, ii) entrar (inserir
elemento) na fila, iii) sair (tirar elemento) da fila, iv) obter
primeiro elemento da fila, e v) testar se fila está vazia, pode ser
implementada como se mostra a seguir.

\subsubsection{Versão funcional}
\index{fila}

Não é eficiente fazer acesso ao último elemento de uma lista em
Haskell. Por isso, a implementação padrão de filas por meio de listas
usa duas listas, \inh{frente} e \inh{tras}: elementos entram na lista
\inh{tras} e saem da lista \inh{frente}. A função \inh{fila} é usada
na definição de \inh{entrar}, para garantir o invariante de que, se
\inh{frente} está vazia, então \inh{tras} está vazia (e, portanto, a
fila está vazia).

\begin{center}
\begin{tabular}{l}
\begin{hask}{fila,vazia,entrar,sair,estaVazia,primeiro}{\definicao}
vazia = ([],[])

entrar e (frente,tras) = fila (frente, e:tras)

fila ([], tras) = (reverse tras, [])
fila f          = f

sair (e:frente, tras) = (frente,tras)

primeiro (e:frente,§{\tt\_}§) = e

estaVazia (frente,§{\tt \_}§)  = null frente
\end{hask}
\end{tabular}
\end{center}

% faltou discutir a ordem de complexidade das operações

\subsubsection{Versão imperativa}
\label{sec:fila-imperativa}
\index{fila}

Na versão imperativa, consideramos uma \ina{fila} como um registro com
campos \ina{inicio}, \ina{fim} e \ina{elems}, sendo \ina{elems} um
arranjo de $n$ elementos (indexado de {\tt 0} a {\tt $n$-1}).  Os
índices do primeiro e do último elementos inseridos na fila são
armazenados respectivamente nas variáveis \ina{inicio} e \ina{fim}.

A fila está vazia quando \ina{inicio == fim}. A fila está cheia
quando \ina{inicio == fim + 1}, isto é, a fila é circular: o
índice {\tt 0} segue o índice {\tt $n$-1}. 

As operações em uma fila podem ser implementadas como a seguir,
desconsiderando-se casos de erro: sair de uma fila vazia e entrar em uma
fila cheia. O operador {\tt \%}, usado na implementação, retorna o resto da
divisão do primeiro operando pelo segundo.

\begin{center}
\begin{tabular}{l}
\begin{alg}{fila,vazia,entrar,sair,estaVazia,primeiro}{\definicao}
vazia (fila) { with fila { inicio = fim = 0 } } 
 
entrar (e, fila)
   with fila
      elems[fim] = e
      fim = (fim + 1) §{\tt \%}§ n
      
sair (fila) { with fila { inicio = (inicio + 1) §{\tt \%}§ n } }
   
primeiro (fila) { return fila.elems[inicio] }

estaVazia (fila) { with fila { return inicio == fim } } 
\end{alg}
\end{tabular}
\end{center} 


