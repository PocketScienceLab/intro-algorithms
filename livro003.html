<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="generator" content="hevea 2.09">
<link rel="stylesheet" type="text/css" href="livro.css">
<title>Introdução</title>
</head>
<body >
<a href="livro002.html"><img src="previous_motif.gif" alt="Previous"></a>
<a href="index.html"><img src="contents_motif.gif" alt="Up"></a>
<a href="livro004.html"><img src="next_motif.gif" alt="Next"></a>
<hr>
<span style="font-family:sans-serif"><span style="font-weight:bold">Introdução a Algoritmos</span></span><h1 id="sec6" class="chapter">Chapter 1  Introdução</h1>
<p>
<a id="Introducao"></a></p><p>Este livro provê uma introdução ao estudo de algoritmos. Ele apresenta
uma introdução a estruturas de dados básicas e algoritmos de pesquisa
e ordenação.</p><p>Vamos identificar neste livro algoritmo com função, no sentido de
prover uma sequência de passos que associa a cada valor de (um
conjunto de valores de) entrada um único valor de (um conjunto de
valores de) saída.</p><p>A diferença que existe entre o conceito usual de função é a notação
usualmente empregada para especificação da sequência de passos. Em
computação, é usual o emprego de uma notação ou lingugem <em>imperativa</em>, ao passo que usualmente definições de funções
empregam uma notação mais <em>declarativa</em>, ou <em>funcional</em>.</p>
<h2 id="sec7" class="section">1.1  Ordenação</h2>
<p>Por exemplo, considere o problema de ordenação, especificado
formalmente como a seguir (um problema computacional especifica a
relação que deve existir entre a entrada e a saída):</p><p><span style="font-weight:bold">Entrada</span>: sequência de elementos <span style="font-style:italic">S</span><sub>0</sub>.</p><p><span style="font-weight:bold">Saída</span>: sequência de elementos ordenada <span style="font-style:italic">S</span> tal que <span style="font-style:italic">S</span> é uma
permutação de <span style="font-style:italic">S</span><sub>0</sub>.</p><p>Uma sequência <span style="font-style:italic">a</span><sub>1</sub>, &#X2026;, <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> é ordenada se <span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span></sub> &#X2264; <span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span>+1</sub> para
<span style="font-style:italic">i</span>=1,&#X2026;, <span style="font-style:italic">n</span>&#X2212;1.</p>
<h3 id="sec8" class="subsection">1.1.1  Sobre Permutação</h3>
<p>Uma permutação (ou arranjo) é uma redisposição de (um conjunto ou
sequência de) elementos em uma certa sequência (se contrapõe a uma
<em>combinação</em>, na qual a ordem dos elementos resultantes não é
relevante). Por exemplo, há 6 permutações distintas dos elementos
1,2,3, que são, escritas como tuplas: (1,2,3), (1,3,2), (2,1,3),
(2,3,1), (3,1,2), (3,2,1).</p><p>Outro nome, usado no contexto de palavras, é <em>anagrama</em>. </p><p>Um anagrama é o resultado de rearranjar as letras de uma palavra ou
frase para produzir uma nova palavra ou frase, usando todas as letras
originais exatamente uma vez. Por exemplo, "ovo" pode ser rearranjado
para "voo".</p><p>Permutações ocorrem em diversas áreas da matemática e proeminentemente
no estudo de algoritmos, particularmente de ordenação, em ciência da
computação.</p><p>O número de permutações de <span style="font-style:italic">n</span> elementos distintos é igual ao fatorial
de <span style="font-style:italic">n</span> (usualmente escrito em matemática como <span style="font-style:italic">n</span>!), que é igual ao
produto de todos os inteiros positivos menores ou iguais a <span style="font-style:italic">n</span>.</p>
<h2 id="sec9" class="section">1.2  Ordenação por Inserção</h2>
<p>Um algoritmo ou função que resolve o problema de ordenação
especificado acima, chamado de <em>ordenação por inserção</em>, é
mostrado a seguir. Ele reflete o modo como um jogador de baralho
usualmente ordena uma sequência de cartas recebidas (por exemplo, em
um jogo de buraco).</p><p>Neste livro, usamos sempre pseudo-códigos com notação funcional e
imperativa para representar cada algoritmo. A notação funcional é a
linguagem <span style="font-family:monospace">Haskell</span> e a notação imperativa é um pseudo-código
semelhante a <span style="font-family:monospace">C</span>, <span style="font-family:monospace">Pascal</span> ou <span style="font-family:monospace">Java</span>.</p><p>O uso da notação funcional pode ser desconsiderado em cursos que
desejam abordar apenas o paradigma de programação imperativo.</p>
<h3 id="sec10" class="subsection">1.2.1  Versão funcional</h3>
<p>
<a id="insertion-sort-func"></a></p><p>A notação funcional será explicada sempre que necessário, isto é,
sempre que houver alguma possibilidade de dúvida. Uma descrição
sucinta da linguagem Haskell é incluída no Apêndice <a href="livro010.html#Ap-Haskell">A</a>
(o leitor não familiarizado com Haskell deve ler o Apêndice
<a href="livro010.html#Ap-Haskell">A</a>). Descrições mais completas de Haskell podem ser
encontradas, por exemplo, em [<a href="livro009.html#PeytonJones92">1</a>, <a href="livro009.html#Thompson99">3</a>].</p><div class="center"><span style="font-family:monospace">
</span><table style="border:0;border-spacing:0" class="cellpadding0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">

</span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">sort</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> []     = []</span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">sort</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> (</span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow">:</span></span><span style="background-color:yellow"><span style="font-style:italic">x</span></span><span style="font-family:monospace"><span style="background-color:yellow">)  = </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">insert</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> (</span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">sort</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">x</span></span><span style="font-family:monospace"><span style="background-color:yellow">)</span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">    </span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">insert</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> []     = []</span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">insert</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> (</span></span><span style="background-color:yellow"><span style="font-style:italic">b</span></span><span style="font-family:monospace"><span style="background-color:yellow">:</span></span><span style="background-color:yellow"><span style="font-style:italic">x</span></span><span style="font-family:monospace"><span style="background-color:yellow">) </span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">   | </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> &lt;= </span></span><span style="background-color:yellow"><span style="font-style:italic">b</span></span><span style="font-family:monospace"><span style="background-color:yellow">     = </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow">: (</span></span><span style="background-color:yellow"><span style="font-style:italic">b</span></span><span style="font-family:monospace"><span style="background-color:yellow"> : </span></span><span style="background-color:yellow"><span style="font-style:italic">x</span></span><span style="font-family:monospace"><span style="background-color:yellow">)</span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">   | </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">otherwise</span></span></span><span style="font-family:monospace"><span style="background-color:yellow">   = </span></span><span style="background-color:yellow"><span style="font-style:italic">b</span></span><span style="font-family:monospace"><span style="background-color:yellow">: </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">insert</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">x</span></span><span style="font-family:monospace"><span style="background-color:yellow">

</span></span></td></tr>
</table><span style="font-family:monospace">
</span></div><p>Explicações sobre a notação funcional (usada em Haskell):</p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-style:italic">f</span> <span style="font-style:italic">x</span> (aplicação funcional &#X2014; a base da programação
funcional) é o mesmo que <span style="font-style:italic">f</span><span style="font-family:monospace">(</span><span style="font-style:italic">x</span><span style="font-family:monospace">)</span> (mas melhor porque evita os
parênteses).</li><li class="li-enumerate"><span style="font-style:italic">b</span><span style="font-family:monospace">: </span><span style="font-family:monospace"><span style="font-style:italic">insert</span></span><span style="font-family:monospace"> </span><span style="font-style:italic">a</span><span style="font-family:monospace"> </span><span style="font-style:italic">x</span> é o mesmo que <span style="font-style:italic">b</span><span style="font-family:monospace">: (</span><span style="font-family:monospace"><span style="font-style:italic">insert</span></span><span style="font-family:monospace"> </span><span style="font-style:italic">a</span><span style="font-family:monospace">
</span><span style="font-style:italic">x</span>): a aplicação funcional tem precedência sobre o uso de
operadores binários.</li><li class="li-enumerate">O uso de um operador binário nada mais é do que uma variação
sintática de (açúcar sintático para) uma aplicação funcional; o uso
de um operador binário pode ser transformado em uma aplicação
funcional, e vice-versa. Para transformar um operador binário em uma
aplicação funcional, basta colocar o operador entre parênteses, e
para transformar uma aplicação funcional em um operador, basta
colocar o nome da função entre crases.
Exemplos: <table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" > <span style="font-family:monospace">2 + 3</span></td><td style="text-align:left;white-space:nowrap" >é equivalente a</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">(+) 2 3</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-style:italic">b</span><span style="font-family:monospace"> : </span><span style="font-style:italic">x</span></td><td style="text-align:left;white-space:nowrap" >é equivalente a</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">(:) </span><span style="font-style:italic">b</span><span style="font-family:monospace"> </span><span style="font-style:italic">x</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > <span style="font-style:italic">f</span> <span style="font-style:italic">x</span> <span style="font-style:italic">y</span></td><td style="text-align:left;white-space:nowrap" >é equivalente a</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">x</span><span style="font-family:monospace"> &#X2018;</span><span style="font-style:italic">f</span><span style="font-family:monospace">&#X2018; </span><span style="font-style:italic">y</span> 
</td></tr>
</table></li><li class="li-enumerate">As funções <span style="font-style:italic">insert</span> and <span style="font-style:italic">sort</span> usam listas, um tipo recursivo, que
é um tipo de dado algébrico (chamado em Haskell de <span style="font-family:monospace">data</span>)
parecido com o seguinte:<div class="center"><span style="font-family:monospace">
</span><table style="border:0;border-spacing:0" class="cellpadding0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">
</span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-family:monospace">data</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">List</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> = </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">Nil</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> | </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">Cons</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> (</span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">List</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow">)
</span></span></td></tr>
</table><span style="font-family:monospace">
</span></div><p>Um tipo de dado algébrico é a maneira como se definem somas (de
tipos, sendo que só podem existir somas disjuntas de tipos), que
modelam escolha (&#X201C;ou&#X201D;) de tipos de dados.</p><p>A declaração de <span style="font-style:italic">List</span> acima especifica que um valor de tipo lista é
polimórfico (o uso da variável de tipo <span style="font-style:italic">a</span> indica que <span style="font-style:italic">List</span> é um
construtor de tipos que pode ser aplicado a <em>qualquer</em> tipo
<span style="font-style:italic">t</span>, isto é, podemos ter qualquer instância <span style="font-style:italic">List</span> <span style="font-style:italic">t</span>, para <em>qualquer</em> tipo <span style="font-style:italic">t</span>), e que uma lista (um valor de tipo
<span style="font-style:italic">List</span> <span style="font-style:italic">t</span>, para algum tipo <span style="font-style:italic">t</span>) pode ser <span style="font-style:italic">Nil</span> (uma lista vazia)
<em>ou</em> <span style="font-family:monospace"><span style="font-style:italic">Cons</span></span><span style="font-family:monospace"> </span><span style="font-style:italic">v</span><span style="font-family:monospace"> </span><span style="font-style:italic">x</span>, uma lista (não vazia) formada por
um valor <span style="font-style:italic">v</span> (cabeça da lista) e de um restante (ou rabo) da lista,
<span style="font-style:italic">x</span> (que deve ser do mesmo tipo da lista da qual é o restante).</p><p>O tipo de listas em Haskell (é parecido mas) difere ligeiramente do
tipo algébrico acima porque o construtor <span style="font-style:italic">Nil</span> é escrito como <span style="font-family:monospace">[]</span> e o construtor <span style="font-style:italic">Cons</span> é escrito como um operador binário <span style="font-family:monospace">:</span>. Assim, em vez de escrever, <span style="font-family:monospace"><span style="font-style:italic">Cons</span></span><span style="font-family:monospace"> 1 </span><span style="font-family:monospace"><span style="font-style:italic">Nil</span></span>, escreve-se em
Haskell <span style="font-family:monospace">1:[]</span>. Além disso, pode-se escrever também <span style="font-family:monospace">[1,2,3]</span> em vez de <span style="font-family:monospace">1:2:3:[]</span> &#X2014; i.e. em vez de <span style="font-family:monospace">1:(2:(3:[]))</span>.</p></li><li class="li-enumerate">Tipos de dados algébricos permitem definir somas (disjuntas) de
tipos, que modelam escolha (&#X201C;ou&#X201D;) de tipos de dados. Para definir
produtos de tipos, podemos usar tipos algébricos, que permitem
produtos &#X201C;linearizados&#X201D; (também chamados de &#X201C;currificados&#X201D;) ou
produtos cartesianos (generalizados), também chamados de tuplas. <p>Por exemplo:</p><div class="center"><span style="font-family:monospace">
</span><table style="border:0;border-spacing:0" class="cellpadding0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">
</span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-family:monospace">data</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">Pair</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">b</span></span><span style="font-family:monospace"><span style="background-color:yellow"> = </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">Pair</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">b</span></span><span style="font-family:monospace"><span style="background-color:yellow">
</span></span></td></tr>
</table><span style="font-family:monospace">
</span></div><p>define um construtor de tipos <span style="font-style:italic">Pair</span>, que tem dois parâmetros que
podem ser instanciados para quaisquer tipos <span style="font-style:italic">t</span> e <span style="font-style:italic">t</span>&#X2032;: por exemplo,
<span style="font-style:italic">Pair</span> <span style="font-style:italic">Int</span> <span style="font-style:italic">Bool</span> representa pares de valores de inteiros e
booleanos (o primeiro componente do par é um inteiro e o segundo um
valor booleano). É semelhante ao produto <span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">Int</span></span><span style="font-family:monospace">,</span><span style="font-family:monospace"><span style="font-style:italic">Bool</span></span><span style="font-family:monospace">)</span>. A
diferença é que valores do primeiro são construídos da forma <span style="font-family:monospace"><span style="font-style:italic">Pair</span></span><span style="font-family:monospace"> 1 </span><span style="font-family:monospace"><span style="font-style:italic">True</span></span> (especificando um valor inteiro e em seguida um
valor booleano), ao passo que valores do segundo são construídos da
forma <span style="font-family:monospace">(1,</span><span style="font-family:monospace"><span style="font-style:italic">True</span></span><span style="font-family:monospace">)</span> (especificando, entre parânteses, primeiro um
valor inteiro, seguido de uma vírgula, e depois um valor booleano).</p></li></ol><p>Para mostrar a correção de <span style="font-style:italic">sort</span>, podemos usar predicados (funções de
contra-domínio <span style="font-style:italic">Bool</span>); vamos provar:</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">sort</span><span style="font-style:italic"> </span><span style="font-style:italic">x</span><span style="font-style:italic"> = </span><span style="font-style:italic">y</span><span style="font-style:italic"> implica:</span> </td></tr>
</table><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-style:italic">sorted</span> <span style="font-style:italic">y</span>
</li><li class="li-enumerate"><span style="font-style:italic">x</span> &#X2018;<span style="font-style:italic">is_a_permutation_of</span>&#X2018; <span style="font-style:italic">y</span></li></ol><p>Temos:</p><div class="center"><span style="font-family:monospace">
</span><table style="border:0;border-spacing:0" class="cellpadding0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">

</span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">sorted</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> []       = </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">True</span></span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">sorted</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> [</span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow">]      = </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">True</span></span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">sorted</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> (</span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow">:</span></span><span style="background-color:yellow"><span style="font-style:italic">b</span></span><span style="font-family:monospace"><span style="background-color:yellow">:</span></span><span style="background-color:yellow"><span style="font-style:italic">x</span></span><span style="font-family:monospace"><span style="background-color:yellow">) = (</span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> &lt;= </span></span><span style="background-color:yellow"><span style="font-style:italic">b</span></span><span style="font-family:monospace"><span style="background-color:yellow">) &amp;&amp; </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">sorted</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> (</span></span><span style="background-color:yellow"><span style="font-style:italic">b</span></span><span style="font-family:monospace"><span style="background-color:yellow">:</span></span><span style="background-color:yellow"><span style="font-style:italic">x</span></span><span style="font-family:monospace"><span style="background-color:yellow">) </span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">     </span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">`</span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">is_a_permutation_of</span></span></span><span style="font-family:monospace"><span style="background-color:yellow">` []      = </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">True</span></span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow"> (</span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow">:</span></span><span style="background-color:yellow"><span style="font-style:italic">x</span></span><span style="font-family:monospace"><span style="background-color:yellow">) `</span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">is_a_permutation_of</span></span></span><span style="font-family:monospace"><span style="background-color:yellow">` </span></span><span style="background-color:yellow"><span style="font-style:italic">y</span></span><span style="font-family:monospace"><span style="background-color:yellow">  = </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">elem</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">y</span></span><span style="font-family:monospace"><span style="background-color:yellow"> &amp;&amp; 
(</span></span><span style="background-color:yellow"><span style="font-style:italic">x</span></span><span style="font-family:monospace"><span style="background-color:yellow"> `</span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">is_a_permutation_of</span></span></span><span style="font-family:monospace"><span style="background-color:yellow">` (</span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">delete</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">y</span></span><span style="font-family:monospace"><span style="background-color:yellow">)) </span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">     </span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> `</span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">elem</span></span></span><span style="font-family:monospace"><span style="background-color:yellow">` []     = </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">False</span></span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> `</span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">elem</span></span></span><span style="font-family:monospace"><span style="background-color:yellow">` (</span></span><span style="background-color:yellow"><span style="font-style:italic">b</span></span><span style="font-family:monospace"><span style="background-color:yellow">:</span></span><span style="background-color:yellow"><span style="font-style:italic">x</span></span><span style="font-family:monospace"><span style="background-color:yellow">) = (</span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> == </span></span><span style="background-color:yellow"><span style="font-style:italic">b</span></span><span style="font-family:monospace"><span style="background-color:yellow">) || (</span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> `</span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">elem</span></span></span><span style="font-family:monospace"><span style="background-color:yellow">` </span></span><span style="background-color:yellow"><span style="font-style:italic">x</span></span><span style="font-family:monospace"><span style="background-color:yellow">)</span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">     </span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">delete</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> []    = []</span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">delete</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> (</span></span><span style="background-color:yellow"><span style="font-style:italic">b</span></span><span style="font-family:monospace"><span style="background-color:yellow">:</span></span><span style="background-color:yellow"><span style="font-style:italic">x</span></span><span style="font-family:monospace"><span style="background-color:yellow">)</span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">  | </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow">==</span></span><span style="background-color:yellow"><span style="font-style:italic">b</span></span><span style="font-family:monospace"><span style="background-color:yellow">        = </span></span><span style="background-color:yellow"><span style="font-style:italic">x</span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">  | </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">otherwise</span></span></span><span style="font-family:monospace"><span style="background-color:yellow">     = </span></span><span style="background-color:yellow"><span style="font-style:italic">b</span></span><span style="font-family:monospace"><span style="background-color:yellow">: </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">delete</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">a</span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">x</span></span><span style="font-family:monospace"><span style="background-color:yellow">

</span></span></td></tr>
</table><span style="font-family:monospace">
</span></div><p>Explicações sobre a notação funcional (usada em Haskell):</p><ol class="enumerate" type=1><li class="li-enumerate"><span style="font-family:monospace">&amp;&amp;</span> e <span style="font-family:monospace">||</span> são operadores binários lógicos de
conjunção e disjunção, respectivamente.</li><li class="li-enumerate">A definição de <span style="font-style:italic">delete</span> usa <em>guardas</em>, que são expressões
booleanas usadas na definição de funções; para cada chamada de
função, a primeira (na ordem textual) guarda cuja avaliação retorna
<span style="font-style:italic">True</span> define o resultado da chamada da função, pela avaliação da
expressão associada a essa guarda (que segue o símbolo <span style="font-family:monospace">=</span>). Por
exemplo, a guarda na definição de <span style="font-style:italic">delete</span> é equivalente a:
<span style="font-family:monospace">if</span> <span style="font-style:italic">a</span>==<span style="font-style:italic">b</span> <span style="font-family:monospace">then</span> <span style="font-style:italic">x</span> <span style="font-family:monospace">else</span> <span style="font-style:italic">b</span>: <span style="font-style:italic">delete</span> <span style="font-style:italic">a</span> <span style="font-style:italic">x</span>.</li></ol><p>Prova: O caso base sai diretamente e o caso indutivo é consequência
dos seguintes lemas:</p><p>Lema 1: Para todo <span style="font-style:italic">a</span>,<span style="font-style:italic">x</span>, 
<span style="font-family:monospace"><span style="font-style:italic">sorted</span></span><span style="font-family:monospace">(</span><span style="font-style:italic">x</span><span style="font-family:monospace">)</span> implica <span style="font-family:monospace"><span style="font-style:italic">sorted</span></span><span style="font-family:monospace">(</span><span style="font-family:monospace"><span style="font-style:italic">insert</span></span><span style="font-family:monospace"> </span><span style="font-style:italic">a</span><span style="font-family:monospace"> </span><span style="font-style:italic">x</span><span style="font-family:monospace">)</span></p><p>Lema 2: Para todo <span style="font-style:italic">a</span>,<span style="font-style:italic">x</span>, 
<span style="font-family:monospace"><span style="font-style:italic">sort</span></span><span style="font-family:monospace"> </span><span style="font-style:italic">x</span><span style="font-family:monospace"> `</span><span style="font-family:monospace"><span style="font-style:italic">is_a_permutation_of</span></span><span style="font-family:monospace">` </span><span style="font-style:italic">x</span> implica 
<span style="font-family:monospace"><span style="font-style:italic">insert</span></span><span style="font-family:monospace"> </span><span style="font-style:italic">a</span><span style="font-family:monospace"> (</span><span style="font-family:monospace"><span style="font-style:italic">sort</span></span><span style="font-family:monospace"> </span><span style="font-style:italic">x</span><span style="font-family:monospace">) `</span><span style="font-family:monospace"><span style="font-style:italic">is_a_permutation_of</span></span><span style="font-family:monospace">` (</span><span style="font-style:italic">a</span><span style="font-family:monospace">:</span><span style="font-style:italic">x</span><span style="font-family:monospace">)</span></p>
<h3 id="sec11" class="subsection">1.2.2  Versão imperativa</h3>
<p>
<a id="insertion-sort-imperativ"></a></p><p>A versão imperativa usa o próprio arranjo para a ordenação (nenhum
outro arranjo ou estrutura de dados auxiliar) e a seguinte ideia:</p><blockquote class="quotation">
insere <span style="font-style:italic">A</span><span style="font-family:monospace">[</span><span style="font-style:italic">j</span><span style="font-family:monospace">]</span> no arranjo ordenado de <span style="font-style:italic">A</span><span style="font-family:monospace">[1]</span> até
<span style="font-style:italic">A</span><span style="font-family:monospace">[</span><span style="font-style:italic">j</span><span style="font-family:monospace">-1]</span>, de <span style="font-style:italic">j</span>=2 até o tamanho do arranjo
</blockquote><p>A ideia dá origem ao seguinte algoritmo, escrito em pseudo-código como
(note que endentação no pseudo-código indica aninhamento na estrutura
de blocos):</p><div class="center"><span style="font-family:monospace">
</span><table style="border:0;border-spacing:0" class="cellpadding0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">

</span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">sort</span></span></span><span style="font-family:monospace"><span style="background-color:yellow">(</span></span><span style="background-color:yellow"><span style="font-style:italic">A</span></span><span style="font-family:monospace"><span style="background-color:yellow">) { </span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">  </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-family:monospace">for</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> j </span></span><span style="background-color:yellow">&#X2190;</span><span style="font-family:monospace"><span style="background-color:yellow"> 2 </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-family:monospace">to</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">length</span></span></span><span style="font-family:monospace"><span style="background-color:yellow">[</span></span><span style="background-color:yellow"><span style="font-style:italic">A</span></span><span style="font-family:monospace"><span style="background-color:yellow">] </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-family:monospace">do</span></span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">    </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">key</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow">&#X2190;</span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">A</span></span><span style="font-family:monospace"><span style="background-color:yellow">[j]</span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">    /* Insere </span></span><span style="background-color:yellow"><span style="font-style:italic">A</span></span><span style="font-family:monospace"><span style="background-color:yellow">[</span></span><span style="background-color:yellow"><span style="font-style:italic">j</span></span><span style="font-family:monospace"><span style="background-color:yellow">] no arranjo ordenado </span></span><span style="background-color:yellow"><span style="font-style:italic">A</span></span><span style="font-family:monospace"><span style="background-color:yellow">[1..</span></span><span style="background-color:yellow"><span style="font-style:italic">j</span></span><span style="font-family:monospace"><span style="background-color:yellow">-1] */ </span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">    </span></span><span style="background-color:yellow"><span style="font-style:italic">i</span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow">&#X2190;</span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">j</span></span><span style="font-family:monospace"><span style="background-color:yellow">-1</span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">    </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-family:monospace">while</span></span></span><span style="font-family:monospace"><span style="background-color:yellow"> (</span></span><span style="background-color:yellow"><span style="font-style:italic">i</span></span><span style="font-family:monospace"><span style="background-color:yellow"> &gt; 0 &amp;&amp; </span></span><span style="background-color:yellow"><span style="font-style:italic">A</span></span><span style="font-family:monospace"><span style="background-color:yellow">[</span></span><span style="background-color:yellow"><span style="font-style:italic">i</span></span><span style="font-family:monospace"><span style="background-color:yellow">]&gt;</span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">key</span></span></span><span style="font-family:monospace"><span style="background-color:yellow">) </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-family:monospace">do</span></span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">       </span></span><span style="background-color:yellow"><span style="font-style:italic">A</span></span><span style="font-family:monospace"><span style="background-color:yellow">[</span></span><span style="background-color:yellow"><span style="font-style:italic">i</span></span><span style="font-family:monospace"><span style="background-color:yellow">+1] </span></span><span style="background-color:yellow">&#X2190;</span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">A</span></span><span style="font-family:monospace"><span style="background-color:yellow">[</span></span><span style="background-color:yellow"><span style="font-style:italic">i</span></span><span style="font-family:monospace"><span style="background-color:yellow">]</span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">       </span></span><span style="background-color:yellow"><span style="font-style:italic">i</span></span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow">&#X2190;</span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="background-color:yellow"><span style="font-style:italic">i</span></span><span style="font-family:monospace"><span style="background-color:yellow"> - 1</span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">    </span></span><span style="background-color:yellow"><span style="font-style:italic">A</span></span><span style="font-family:monospace"><span style="background-color:yellow">[</span></span><span style="background-color:yellow"><span style="font-style:italic">i</span></span><span style="font-family:monospace"><span style="background-color:yellow">+1] </span></span><span style="background-color:yellow">&#X2190;</span><span style="font-family:monospace"><span style="background-color:yellow"> </span></span><span style="font-family:monospace"><span style="background-color:yellow"><span style="font-style:italic">key</span></span></span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace"><span style="background-color:yellow">}

</span></span></td></tr>
</table><span style="font-family:monospace">
</span></div><p>A correção do algoritmo advém de que o invariante, especificado
bastante informalmente como:</p><blockquote class="quotation">
&#X2014; no início da execução de cada iteração do comando <span style="font-family:monospace">for</span>, o
sub-arranjo <span style="font-style:italic">A</span><span style="font-family:monospace">[1..</span><span style="font-style:italic">j</span><span style="font-family:monospace">-1]</span> contém os elementos que estavam
originalmente nesse sub-arranjo, mas de forma ordenada &#X2014;
</blockquote><p>é verdadeiro no início (antes da execução da primeira iteração do
<span style="font-family:monospace">for</span>), antes e após cada iteração, e no final, quando então a
terminação garante a correção do algoritmo (ordenamento de todo o
arranjo).</p><p>É importante observar que a transformação dessa prova informal em uma
prova formal é relativamente muito mais difícil do que no caso
funcional.</p><p>No próximo capítulo vamos introduzir introduzir a notação e os
conceitos principais usados para análise da complexidade (eficiência)
de algoritmos, para que possamos analisar a complexidade de algoritmos
(começando pela complexidade dos algoritmos apresentados neste
capítulo).</p>
<hr>
<a href="livro002.html"><img src="previous_motif.gif" alt="Previous"></a>
<a href="index.html"><img src="contents_motif.gif" alt="Up"></a>
<a href="livro004.html"><img src="next_motif.gif" alt="Next"></a>
</body>
</html>
