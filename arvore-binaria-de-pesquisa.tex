% !TEX encoding = ISO-8859-1
\section{Árvore binária de pesquisa}
\label{sec:arvore-binaria-de-pesquisa}

Uma árvore binária de pesquisa é uma árvore binária --- isto é, um
árvore com duas sub-árvores (possivelmente vazias), digamos, à
esquerda e à direita --- com os elementos contidos nos nodos, um
elemento por nodo, e tal que: todo elemento contido em um nodo é maior
que os elementos contidos na sub-árvore à esquerda deste nodo e menor
que os elementos contidos na sub-árvore à direita do nodo.

Dois exemplos de árvores binárias de pesquisa com os elementos de 1 a
7 são mostradas abaixo. 

\begin{verbatim}
      4                    4
     / \                  / \
    1   5                2   6
     \   \              / \  /\
     3    6            1  3 5  7 
    /      \ 
    2       7
\end{verbatim}

A propriedade fundamental de uma árvore binária de pesquisa é o acesso
eficiente a um elemento (veja abaixo comentário sobre a complexidade
logarítmica da pesquisa por um elemento no caso médio).

Uma árvore binária de pesquisa é uma importante estruturas de dados,
gerando implementações simples de pesquisa, inserção e remoção. Em
computação, um {\em dicionário\/} é um tipo abstrato que define tais
operações. As seções seguintes apresentam versões recursivas e
iterativas de pesquisa, inserção e remoção, usando árvores binárias de
pesquisa.

\subsection{Versão funcional}

Considere a definição de árvore binária com elementos nos nodos
internos da árvore apresentada na seção \ref{sec:arvores}:

\begin{center}
\begin{tabular}{l}
\begin{hask}{ArvB,FolhaB,NodoB}{White}
 data ArvB a = FolhaB | NodoB a (ArvB a) (ArvB a)
\end{hask}
\end{tabular}
\end{center}

\subsubsection{Pesquisa}

A pesquisa por um elemento em uma árbore de pesquisa binária é um
algoritmo simples, mostrado a seguir:

\begin{center}
\begin{tabular}{l}
\begin{hask}{pesq}{\decremento}
pesq v FolhaB          = False
pesq v (NodoB v' t t') = case compare v v' of
                           LT -> pesq v t
                           GT -> pesq v t'
                           _  -> True
\end{hask}
\end{tabular}
\end{center}

A complexidade de tempo de \inh{pesq} é determinada a seguir: 

\begin{enumerate}

  \item Vamos considerar que o tamanho da entrada é dado pelo número
    de elementos $n$ na árvore.

  \item As operações relevantes são as comparações de igualdade
    (\inh{==}) e menor-que (\inh{<}). 

  \item \label{complexidade-da-pesquisa-binaria-no-pior-caso} A
    expressão-determinante-da-eficiência é, no pior caso, igual a
    $T(n-1) + k$, onde $k$ é uma constante que expressa o tempo de
    execução da comparação. No pior caso, o elemento está em
    sub-árvore que contém $n-1$ nodos: todos os nodos menos o nodo
    corrente. Neste caso, a árvore está desbalanceada. Isso ocorre,
    por exemplo, para as árvores mostradas a seguir, construídas com
    inserções sucessivas de elementos em uma lista crescente e
    decrescente, respectivamente.

    \begin{verbatim}
         v0                             v0
          \                             /
          v1                           v1
            \                         /
            ...                     ...
              \                     /
              vn-1               vn-1
                \                 /
                 vn              vn
    \end{verbatim}

  \end{enumerate}

Assim, a relação de recorrência neste caso é:

   \[ T(n) = T(n-1) + k \]

A solução dessa relação de recorrência foi apresentada na seção
\ref{sec:maior-elemento}:

       \[ T(n) \asymp n \]

Note que o algoritmo de pesquisa em uma árvore binária de pesquisa tem
complexidade $O(p)$ no pior caso, onde $p$ é a profundidade da árvore
(número de arestas do maior caminho existente entre a raiz e uma
folha). 

Em uma árvore balanceada, o número de elementos $n$ é igual a $2^p$,
ou seja, em uma árvore balanceada, a pesquisa tem complexidade 

  \[ T(n) \asymp lg n \]
Em uma árvore totalmente desbalanceada, temos no entanto $p = n-1$.

\subsubsection{Inserção}

O algoritmo para inserção de elementos em uma árvore binária de
pesquisa é semelhante ao algoritmo de pesquisa:

\begin{center}
\begin{tabular}{l}
\begin{hask}{ins}{\decremento}
ins v FolhaB             = NodoB v FolhaB FolhaB
ins v t@(NodoB v' t1 t2) = case compare v v' of
                             LT -> ins v t1
                             GT -> ins v t2
                             _  -> t
\end{hask}
\end{tabular}
\end{center}

O tempo de complexidade do algoritmo de inserção é o mesmo do de
pesquisa: $lg n$ no caso de uma árvore balanceada, mas linear no pior
caso de uma árvore desbalanceada.

\subsubsection{Remoção}

Para remoção de um nodo $n$, raiz de uma árvore $t$, o algoritmo de
remoção de elemento essencialmente subsititui $n$ pelo menor elemento
da sub-árvore direita de $t$ (e remove este menor elemento dessa
sub-árvore). O algoritmo em Haskell é apresentado a seguir.

\begin{center}
\begin{tabular}{l}
\begin{hask}{remov}{\decremento}
remov:: Ord a => a -> ArvB a -> ArvB a
remov _ FolhaB = FolhaB
remov a (NodoB b l r) = case compare a b of 
                          LT -> NodoB b (remov a l) r
                          GT -> NodoB b l (remov a r)
                          _  -> junta l r

junta:: Ord a => ArvB a -> ArvB a -> ArvB a
-- junta l r cria árvore com o menor elemento m de r como raiz e remove m de r, 
-- se m existir; senão (r é vazia) retorna l.
junta l r = case min r of 
              Nothing     -> l
              Just (m,r') -> Node m l r'

min:: Ord a => ArvB a -> Maybe (a,ArvB a)
-- min t retorna Just (m,r) se o menor elemento m de t existir
-- (onde r é a sub-árvore direita de t); senão Nothing.
min FolhaB             = Nothing
min (NodoB a FolhaB r) = Just (a, r)
min (NodoB a l      r) = Just (m,r)
  where Just (m,_)     = min l
\end{hask}
\end{tabular}
\end{center}

O tempo de complexidade do algoritmo de remoção de elementos é também
o mesmo do de pesquisa: $lg n$ no caso de uma árvore balanceada, mas
linear no pior caso de uma árvore desbalanceada.

\subsection{Versão imperativa}

Vamos usar a definição de árvore binária apresentada na seção
\ref{sec:arvores}:

\begin{center}
\begin{tabular}{l}
\begin{alg}{ArvoreBinariaDeInteiros}{White}
struct ArvoreBinariaDeInteiros
     int elem
     struct ArvoreBinariaDeInteiros *esq, dir 
\end{alg}
\end{tabular}
\end{center}

\subsubsection{Pesquisa}

A pesquisa iterativa por um valor em uma árvore binária de pesquisa
com valores inteiros é apresentada a seguir:

\begin{center}
\begin{tabular}{l}
\begin{alg}{pesq}{\decremento}
pesq(k, arvBin) 
    nodoCorrente §$\from$§ arvBin
    while nocoCorrente != NULL
        v §$\from$§ nocoCorrente->elem
        if v > k 
           nodoCorrente §$\from$§ nodoCorrente->esq else
        if v < k
            nodoCorrente §$\from$§ nodoCorrente->dir
        else return nodoCorrente
    return NULL
\end{alg}
\end{tabular}
\end{center}

A complexidade é a mesma da versão recursiva: $lg n$ no caso de uma
árvore balanceada, mas linear no pior caso de uma árvore
desbalanceada.

\subsubsection{Inserção}

A inserção de elemento na versão imperativa supõe que o elemento a ser
inserido é um novo elemento (não ocorre na árvore). É usado comando de
repetição em vez de recursão, e comando de atribuição é usado para
modificar a árvore na qual o elemento está sendo inserido, em vez de
criar nova árvore.

Um novo nodo é criado com chamada a \ina{novoNodo}, que atribui
referências nulas aos campos \ina{esq} e \ina{dir} e atribui o
argumento ao campo \ina{elem}.

\begin{center}
\begin{tabular}{l}
\begin{alg}{ins}{\decremento}
ins (int k, ArvoreBinariaDeInteiros* arvBin) {
  ArvoreBinariaDeInteiros* nodoCorrente = arvBin
  ArvoreBinariaDeInteiros* prev = NULL
  int v
  while (nodoCorrente != NULL) 
    v §$\from$§ nodoCorrente->elem;
    prev §$\from$§ nodoCorrente;
    if (k < v) 
       nodoCorrente §$\from$§ nodoCorrente -> esq
    else 
       nodoCorrente §$\from$§ nodoCorrente -> dir

  if prev == NULL
    arvBin §$\from$§ novoNodo(k)
  else 
    if (k < prev->elem) 
      prev->esq §$\from$§ novoNodo(k)
    else 
      prev->dir §$\from$§ novoNodo(k)
\end{alg}
\end{tabular}
\end{center}

A complexidade de \ina{ins} é a mesma da versão recursiva: $lg n$ no
caso de uma árvore balanceada, mas linear no pior caso de uma árvore
desbalanceada.

A versão imperativa do algoritmo de remoção de um elemento em uma
árvore binária de pesquisa é deixada como exercício para o leitor
(exercício \ref{remocao-de-elemento-em-arvore-binaria-de-pesquisa}).

\HRule

%Embora a complexidade da pesquisa a um elemento seja logarítmica no
%caso médio, como vimos no item
%\ref{complexidade-da-pesquisa-binaria-no-pior-caso} acima, no pior
%caso a complexidade da pesquisa é a mesma da complexidade da pesquisa
%sequencial, quando a árvore está totalmente desbalanceada, ficando
%equivalente a uma lista.

Há muitos trabalhos de pesquisa em computação que procuram preservar o
balanceamento de árvores binárias de pesquisa, para manter a
propriedade de complexidade logarítmica para as operações de inserção,
remoção, pesquisa e ordenação de valores, baseados principalmente em
técnicas de transformação: simplificação ou mudança de representação.

A simplificação transforma árvores não balanceadas em árvores
balanceadas (segundo alguma critério de balanceamento) sem adicionar
nenhuma informação adicional a nodos da árvore. A seção
\ref{sec:arvore-AVL} aborda {\em árvores AVL\/}, nas quais a diferença
entre a altura das sub-árvores de qualquer nodo não deve ser maior que
1. A altura de um nodo da árvore é o número de nodos do maior caminho
entre esse nodo e uma folha. A altura de uma árvore é altura do nodo
raiz da árvore.

Outro estrutura de dados que provê balanceamento de árvores de
pesquisa baseada na técnica de transformação por simplificação é a que
vamos chamar de {\em árvores MovPraRaiz\/} (em inglês, {\em splay
  trees\/}), baseada na ideia de mover para raiz um elemento em
operações de inserção, remoção ou pesquisa.  Árvores MovPraRaiz são
abordadas no exercício resolvido \ref{ex:arvores-MovPraRaiz}.

Exemplos de balanceamento via mudança de representação ocorrem com os
seguintes tipos de árvore: {\em árvore bicolor\/} (também chamadas de
vermelha-e-preta ou rubro-negra, em inglês {\em red-black tree\/}) e
{\em árvore B\/} (em inglês, {\em B-tree\/}), abordadas
respectivamente nas seções \ref{sec:arvore-bicolor} e
\ref{sec:arvore-B}.

\section{Árvore AVL}
\label{sec:arvore-AVL}

O nome AVL é proveniente das iniciais dos sobrenomes dos dois
pesquisadores russos G.~M.~\underline{A}delson-\underline{V}elsky e
E.~M.~\underline{L}andis, que foram os primeiros a definir e realizar
trabalhos com esse tipo de árvore.

Seja $n$ um nó de uma árvore binária, $ad_n$ e $ae_n$ as alturas da
sub-árvore esquerda e direita de $n$, respectivamente, e seja $k_n =
ae_n - ad_n $ o {\em fator de balanceamento\/} do nodo (i.e.~o fator
de balanceamento é igual ao valor da diferença entre as alturas de
suas sub-árvores).

Uma árvore AVL é uma árvore de pesquisa binária na qual $\delta_n$ é
igual a 0 ou 1 ou -1, para todo nodo $n$.

Por exemplo, a ávore binária de pesquisa abaixo à esquerda é uma
árvore AVL, enquanto a da direita não é. 

\begin{verbatim}
      5                 5
     / \               /
    2   6             2 
   /                 / 
  1                 1   
\end{verbatim}

O algoritmo de pesquisa em uma árvore AVL é o mesmo do algoritmo de
pesquisa em uma árvore binária de pesquisa. 

Os algoritmos de inserção e remoção são apresentados nas subseções
seguintes.

\subsection{Inserção}
\label{sec:insercao-em-arvores-AVL-versao-func}

Após inserção de nodo em uma árvore AVL, é feita uma verificação do
fator de balanceamento de cada nodo que está no caminho da raiz até o
nodo inserido. Se a inserção tornar o fator de balanceamento maior que
1 ou menor que -1, a sub-árvore com raiz nesse nodo é rebalanceada,
por meio de uma {\em rotação}, para que a condição-AVL volte a ser
satisfeita. Como a inserção de elemento em uma árvore pode aumentar a
altura da árvore em no máximo 1, o fator de balanceamento deve ser,
logo após a inserção de nodo na sub-árvore esquerda e antes do
rebalanceamento, no máximo igual a 2; e, logo após a inserção de nodo
na sub-árvore direita e antes do rebalanceamento, no mínimo igual a
-2.

Quando o fator de balanceamento é igual a 2, existem duas
possibilidades (outras duas possibilidades, que existem quando o fator
de balanceamento é igual a -2, são análogas). 

\newcommand{\altura}{{\it altura\/}}

A primeira, mostrada no caso \verb+sobE+ abaixo, temos 
  $\text{\altura\ (\verb+ee+) = \altura\ (\verb+d+)}$.
Note que: 
  \begin{enumerate}
    \item se
      $\altura\ (\verb+ee+) < \altura\ (\verb+d+)$ então a
      árvore continuaria sendo uma árvore AVL após a inserção de um
      nodo em \verb+ee+;
    \item se $\altura\ (\verb+ee+) > \altura\ (\verb+d+)$ então a
      árvore já não seria uma árvore AVL antes da inserção de um nodo
      em \verb+ee+.
  \end{enumerate}
   
\begin{verbatim}
       Caso sobE      Caso sobED
           v              v
         /   \          /   \   
        ve    d        ve    d
       /  \           /  \                    
      ee  ed         ee   ved
                         / \
                       ede  edd                   

Árvore depois de rotacionada:

    Caso sobE          Caso sobED
     ve                   ved
    /  \                /     \ 
   ee   v             ve       v
       / \           /  \     / \ 
      ed  d         ee  ede edd  d

\end{verbatim}

O caso \verb+sobED+ pode ser expresso como \verb+sobE+ (aplicado ao
nodo com raiz \verb+ved+) seguido de \verb+sobD+ (aplicado ao mesmo
nodo).

%É importante notar que apenas um fator de balanceamento não é
%suficiente para determinar se uma árvore AVL necessita de rotação após
%uma inserção. Por exemplo, considere as duas árvores AVL a seguir:
%
%\begin{verbatim}
%      7                  7
%     /  \               /
%    3    8             3 
%   / \    \ 
%  2   5    9
% /     \ 
%1       6
%\end{verbatim}
%
%O fator de balanceamento da árvore com raiz \verb+7+ é igual a 1, nas
%duas árvores acima, antes da inserção.  No entanto, a inserção de
%\verb+4+ não quebra a condição de a árvore à esquerda ser AVL, ao
%contrário do que ocorre no caso da árvore à direita; após a inserção,
%e antes da rotação, que deve ser feita apenas na árvore à direita,
%temos:
%
%\begin{verbatim}
%     AVL              Não AVL 
%      7                  7
%     / \                /
%    3   8              3 
%   / \   \             \ 
%  2   5   9             4
% /   / \ 
%1   4   6
%\end{verbatim}

A tarefa de determinar, usando apenas o próprio fator de
balanceamento, a variação do fator de balanceamento após uma inserção,
e demonstrar que tal variação é verificada em todos os casos, é
deixada para trabalho futuro. Não encontramos na literatura textos que
abordam o assunto de forma clara e precisa.

O armazenamento da altura em cada nodo evita ter que calcular a altura
de cada nodo que está no caminho da árvore até o nodo inserido, o que
seria desnecessariamente ineficiente. 

\subsubsection{Versão funcional}

A inserção de elemento em árvore AVL é feita em Haskell como a seguir:

\begin{center}
\begin{tabular}{l}
\begin{hask}{ins}{\decremento}
module AVL (ArvoreAVL, arvVazia, ins) where

type Altura      = Integer
data ArvoreAVL a = Vazia | Nodo a Altura (ArvoreAVL a) (ArvoreAVL a)

arvVazia = Vazia

ins:: (Show a, Ord a) => a -> ArvoreAVL a -> ArvoreAVL a
ins k Vazia              = Nodo k 1 Vazia Vazia
ins k arv@(Nodo v _ e d) = 
 case compare k v of 
  LT -> let e1@(Nodo v1 a1 _ _) = ins k e 
            ad = altura d
         in if a1 - ad == 2 -- condição AVL precisa ser restaurada
            then if k < v1  
                 then sobE  (Nodo v undefined e1 d)  
                 else sobED (Nodo v undefined e1 d)
            else Nodo v (max a1 ad + 1) e1 d
  GT -> let d1@(Nodo v1 a1 _ _) = ins k d 
            ae = altura e
         in if a1 - ae == 2 -- condição AVL precisa ser restaurada 
            then 
               if k > v1
               then sobD  (Nodo v undefined e d1) 
               else sobDE (Nodo v undefined e d1) 
            else Nodo v (max ae a1 + 1) e d1
  _ -> arv

sobE :: ArvoreAVL a -> ArvoreAVL a
sobE (Nodo v _ (Nodo ve _ ee ed) d) = Nodo ve a ee (Nodo v ad ed d) 
  where ad = max (altura ed) (altura d) + 1
        a  = max (altura ee) ad         + 1

sobD :: ArvoreAVL a -> ArvoreAVL a
sobD (Nodo v _ e (Nodo vd _ de dd)) = Nodo vd a (Nodo v ae e de) dd
  where ae = max (altura e) (altura de) + 1
        a  = max ae         (altura dd) + 1

sobED :: ArvoreAVL a -> ArvoreAVL a
sobED (Nodo v _ (Nodo ve _ ee (Nodo ved _ ede edd)) d) = 
       Nodo ved a (Nodo ve ae ee ede) (Nodo v ad edd d)
  where a  = max ae           ad           + 1
        ae = max (altura ee ) (altura ede) + 1
        ad = max (altura edd) (altura d  ) + 1

sobDE :: ArvoreAVL a -> ArvoreAVL a
sobDE (Nodo v _ e (Nodo vd _ (Nodo vde _ dee ded) dd)) = 
       Nodo vde a (Nodo v ae e dee) (Nodo vd ad ded dd)
  where a  = max ae           ad           + 1
        ad = max (altura ded) (altura dd ) + 1
        ae = max (altura e  ) (altura dee) + 1 

altura (Nodo _ a _ _) = a
altura Vazia          = 0
\end{hask}
\end{tabular}
\end{center}

No pior caso, temos $T(h) = T(h-1) + k$, onde $h$ é a altura da árvore
e $k$ é o tempo de execução referente aos cálculos de i) altura de uma
sub-árvore, ii) condição AVL e iii) rotação (uma das funções
\inh{sobE}, \inh{sobED}, \inh{sobD}, \inh{sobDE}). Todos os tempos de
i) a iii) têm complexidade $O(1)$. Logo (cf.~seção
\ref{sec:maior-elemento}): $T(h) \asymp h$, ou seja, considerando que
$h \asymp lg n$ em uma árvore balanceada (onde $n$ é o número de
elementos da árvore):

  \[ T(n) \asymp lg n \]

\subsubsection{Versão imperativa}

\begin{center}
\begin{tabular}{l}
\begin{alg}{ArvoreBinariaDeInteiros}{White}
struct AVL
    int chave
    struct AVL *esq
    struct AVL *dir
    int alturaEsq, alturaDir
 
int altura (struct node *pnodo)
    if (pnodo == NULL)
        return 0
    return pnodo->altura
 
int max(int a, int b)
    if a > b return a else return b
 
struct node* novoNodo (int chave)
    struct AVL* nodo = (struct AVL*) malloc(sizeof(struct AVL))
    nodo->chave  = chave
    nodo->esq    = NULL;
    nodo->dir    = NULL;
    nodo->altura = 1 // novo nodo é folha
    return nodo
 
struct node *rightRotate(struct node *y)
    struct node *x = y->left;
    struct node *T2 = x->right;
 
    // Perform rotation
    x->right = y;
    y->left = T2;
 
    // Update heights
    y->height = max(height(y->left), height(y->right))+1;
    x->height = max(height(x->left), height(x->right))+1;
 
    // Return new root
    return x;
 
struct node *leftRotate(struct node *x)
    struct node *y = x->right;
    struct node *T2 = y->left;
 
    // Perform rotation
    y->left = x;
    x->right = T2;
 
    //  Update heights
    x->height = max(height(x->left), height(x->right))+1;
    y->height = max(height(y->left), height(y->right))+1;
 
    // Return new root
    return y;
 
int getBalance(struct node *N)
    if (N == NULL)
        return 0;
    return height(N->left) - height(N->right);
 
struct node* insert(struct node* node, int key)
    /* 1.  Perform the normal BST rotation */
    if (node == NULL)
        return(newNode(key));
 
    if (key < node->key)
        node->left  = insert(node->left, key);
    else
        node->right = insert(node->right, key);
 
    /* 2. Update height of this ancestor node */
    node->height = max(height(node->left), height(node->right)) + 1;
 
    /* 3. Get the balance factor of this ancestor node to check whether
       this node became unbalanced */
    int balance = getBalance(node);
 
    // If this node becomes unbalanced, then there are 4 cases
 
    // Left Left Case
    if (balance > 1 && key < node->left->key)
        return rightRotate(node);
 
    // Right Right Case
    if (balance < -1 && key > node->right->key)
        return leftRotate(node);
 
    // Left Right Case
    if (balance > 1 && key > node->left->key)
    {
        node->left =  leftRotate(node->left);
        return rightRotate(node);
    }
 
    // Right Left Case
    if (balance < -1 && key < node->right->key)
    {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }
 
    /* return the (unchanged) node pointer */
    return node;
\end{alg}
\end{tabular}
\end{center}

\subsection{Remoção}

\subsubsection{Versão funcional}

\subsubsection{Versão imperativa}

\section{Árvore Bicolor}
\label{sec:arvore-bicolor}

Uma árvore bicolor --- ou rubro-negra, ou vermelha-e-preta --- é uma
árvore binária de pesquisa com uma informação em cada nodo que indica
sua cor --- vamos chamar um nodo de cor $A$ de nodo $A$ e um nodo de
cor $B$ de nodo $B$ (em geral, as cores $A$ e $B$ são vermelha e
preta) --- e que deve além disso satisfazer às seguintes condições
(chamadas de {\em condições-de-árvore-bicolor\/}):

\begin{enumerate}

\item As folhas e a raiz são nodos $B$.

\item Os filhos de todo nodo $A$ são nodos $B$.

\item Todo caminho de um nodo a uma folha contém o mesmo número de
  nodos $B$.

\end{enumerate}

Um exemplo de uma árvore bicolor é mostrada abaixo.

.... aqui vem figura de árvore vermelha-e-preta. ....

As duas últimas condições garantem a propriedade {\em
  balanceamento-bicolor\/}: o comprimento do caminho mais longo da
raiz a uma folha não é maior que o dobro do comprimento do menor
caminho da raiz a uma folha. Ou seja, a árvore é razoavelmente bem
balanceada em termos de altura dos seus nodos (altura = comprimento do
maior caminho do nodo até uma folha). Como o pior caso da complexidade
de tempo de operações de inserção, remoção e pesquisa são
proporcionais à altura da árvore, isso permite uma eficiência maior do
que árvores binárias de pesquisa.

Para ver porque as duas últimas condições garantem a propriedade de
balanceamento-bicolor, considere que $n_p$ seja o número de nodos $B$
de um caminho a uma folha, para uma árvore $a$.  Seja $k$ o
comprimento do menor caminho $c_m$ da raiz a uma folha (esse caminho
contém $n_b$ nodos pretos). O caminho mais longo da raiz a uma folha
$c_M$ não pode conter nodos vermelhos em níveis consecutivos da árvore
(um novo vermelho não pode ser filho de outro nodo vermelho), e o
número de nodos $B$ tem que ser igual a $n_p$. Portanto, o número de
nodos de $c_M$ tem que ser no máximo igual a $2*k$ (caso em que $c_m$
só tem nodos $B$).

Operações que modificam a árvore geralmente causam reorganização dos
nodos e cores dos nodos de modo a que as condições-de-árvore-bicolor
continuem a ser satisfeitas, o que pode ser feito de modo eficiente.

% The balancing of the tree is not perfect but it is good enough to
% allow it to guarantee searching in O(log n) time, where n is the total
% number of elements in the tree. The insertion and deletion operations,
% along with the tree rearrangement and recoloring, are also performed
% in O(log n) time.

\section{Árvore B}
\label{sec:arvore-B}
