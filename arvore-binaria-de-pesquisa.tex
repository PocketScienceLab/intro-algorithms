% !TEX encoding = ISO-8859-1
\section{Árvore binária de pesquisa}
\label{sec:arvore-binaria-de-pesquisa}

Uma árvore binária de pesquisa é uma árvore binária --- isto é, um
árvore com duas sub-árvores (possivelmente vazias), digamos, à
esquerda e à direita --- com os elementos contidos nos nodos, um
elemento por nodo, e tal que: todo elemento contido em um nodo é maior
que os elementos contidos na sub-árvore à esquerda deste nodo e menor
que os elementos contidos na sub-árvore à direita do nodo.

Dois exemplos de árvores binárias de pesquisa com os elementos de 1 a
7 são mostradas abaixo. 

\begin{verbatim}
      4                    4
     / \                  / \
    1   5                2   6
     \   \              / \  /\
     3    6            1  3 5  7 
    /      \ 
    2       7
\end{verbatim}

A propriedade fundamental de uma árvore binária de pesquisa é o acesso
eficiente a um elemento (veja abaixo comentário sobre a complexidade
logarítmica da pesquisa por um elemento no caso médio).

Uma árvore binária de pesquisa é uma importante estruturas de dados,
gerando implementações simples de pesquisa, inserção e remoção. Em
computação, um {\em dicionário\/} é um tipo abstrato que define tais
operações. As seções seguintes apresentam versões recursivas e
iterativas de pesquisa, inserção e remoção, usando árvores binárias de
pesquisa.

\subsection{Versão funcional}

Considere a definição de árvore binária com elementos nos nodos
internos da árvore apresentada na seção \ref{sec:arvores}:

\begin{center}
\begin{tabular}{l}
\begin{hask}{ArvB,FolhaB,NodoB}{White}
 data ArvB a = FolhaB | NodoB a (ArvB a) (ArvB a)
\end{hask}
\end{tabular}
\end{center}

\subsubsection{Pesquisa}

A pesquisa por um elemento em uma árbore de pesquisa binária é um
algoritmo simples, mostrado a seguir:

\begin{center}
\begin{tabular}{l}
\begin{hask}{pesq}{\decremento}
pesq v FolhaB          = False
pesq v (NodoB v' t t') = case compare v v' of
                           LT -> pesq v t
                           GT -> pesq v t'
                           _  -> True
\end{hask}
\end{tabular}
\end{center}

A complexidade de tempo de \inh{pesq} é determinada a seguir: 

\begin{enumerate}

  \item Vamos considerar que o tamanho da entrada é dado pelo número
    de elementos $n$ na árvore.

  \item A operações relevantes são a comparação (uso de \inh{compare})
    e o casamento de padrão.

  \item \label{complexidade-da-pesquisa-binaria-no-pior-caso} A
    expressão-determinante-da-eficiência é, no pior caso, igual a
    $T(n-1) + k$, onde $k$ é uma constante que expressa o tempo de
    execução da comparação. No pior caso, o elemento está em
    sub-árvore que contém $n-1$ nodos: todos os nodos menos o nodo
    corrente. Neste caso, a árvore está desbalanceada. Isso ocorre,
    por exemplo, para as árvores mostradas a seguir, construídas com
    inserções sucessivas de elementos em uma lista crescente e
    decrescente, respectivamente.

    \begin{verbatim}
         v0                             v0
          \                             /
          v1                           v1
            \                         /
            ...                     ...
              \                     /
              vn-1               vn-1
                \                 /
                 vn              vn
    \end{verbatim}

  \end{enumerate}

Assim, a relação de recorrência neste caso é:

   \[ T(n) = T(n-1) + k \]

A solução dessa relação de recorrência foi apresentada na seção
\ref{sec:maior-elemento}:

       \[ T(n) \asymp n \]

Note que o algoritmo de pesquisa em uma árvore binária de pesquisa tem
complexidade $O(p)$ no pior caso, onde $p$ é a profundidade da árvore
(número de arestas do maior caminho existente entre a raiz e uma
folha). 

Em uma árvore balanceada, o número de elementos $n$ é igual a $2^p$,
ou seja, em uma árvore balanceada, a pesquisa tem complexidade 

  \[ T(n) \asymp lg n \]
Em uma árvore totalmente desbalanceada, temos no entanto $p = n-1$.

\subsubsection{Inserção}

O algoritmo para inserção de elementos em uma árvore binária de
pesquisa é semelhante ao algoritmo de pesquisa:

\begin{center}
\begin{tabular}{l}
\begin{hask}{ins}{\decremento}
ins v FolhaB             = NodoB v FolhaB FolhaB
ins v t@(NodoB v' t1 t2) = case compare v v' of
                             LT -> ins v t1
                             GT -> ins v t2
                             _  -> t
\end{hask}
\end{tabular}
\end{center}

O tempo de complexidade do algoritmo de inserção é o mesmo do de
pesquisa: $lg n$ no caso de uma árvore balanceada, mas linear no pior
caso de uma árvore desbalanceada.

\subsubsection{Remoção}

Para remoção de um nodo $n$, raiz de uma árvore $t$, o algoritmo de
remoção de elemento essencialmente subsititui $n$ pelo menor elemento
da sub-árvore direita de $t$ (e remove este menor elemento dessa
sub-árvore). O algoritmo em Haskell é apresentado a seguir.

\begin{center}
\begin{tabular}{l}
\begin{hask}{remov}{\decremento}
remov:: Ord a => a -> ArvB a -> ArvB a
remov _ FolhaB = FolhaB
remov a (NodoB b l r) = case compare a b of 
                          LT -> NodoB b (remov a l) r
                          GT -> NodoB b l (remov a r)
                          _  -> junta l r

junta:: Ord a => ArvB a -> ArvB a -> ArvB a
-- junta l r cria árvore com o menor elemento m de r como raiz e remove m de r, 
-- se m existir; senão (r é vazia) retorna l.
junta l r = case min r of 
              Nothing     -> l
              Just (m,r') -> Node m l r'

min:: Ord a => ArvB a -> Maybe (a,ArvB a)
-- min t retorna Just (m,r) se o menor elemento m de t existir
-- (onde r é a sub-árvore direita de t); senão Nothing.
min FolhaB             = Nothing
min (NodoB a FolhaB r) = Just (a, r)
min (NodoB a l      r) = Just (m,r)
  where Just (m,_)     = min l
\end{hask}
\end{tabular}
\end{center}

O tempo de complexidade do algoritmo de remoção de elementos é também
o mesmo do de pesquisa: $lg n$ no caso de uma árvore balanceada, mas
linear no pior caso de uma árvore desbalanceada.

\subsection{Versão imperativa}

Vamos usar a definição de árvore binária apresentada na seção
\ref{sec:arvores}:

\begin{center}
\begin{tabular}{l}
\begin{alg}{ArvoreBinariaDeInteiros}{White}
struct ArvoreBinariaDeInteiros
     int elem
     struct ArvoreBinariaDeInteiros *esq, dir 
\end{alg}
\end{tabular}
\end{center}

\subsubsection{Pesquisa}

A pesquisa iterativa por um valor em uma árvore binária de pesquisa
com valores inteiros é apresentada a seguir:

\begin{center}
\begin{tabular}{l}
\begin{alg}{pesq}{\decremento}
pesq(k, arvBin) 
    nodoCorrente = arvBin
    while nocoCorrente != NULL
        v = nocoCorrente->elem
        if v > k 
           nodoCorrente = nodoCorrente->esq else
        if v < k
            nodoCorrente = nodoCorrente->dir
        else return nodoCorrente
    return NULL
\end{alg}
\end{tabular}
\end{center}

A complexidade é a mesma da versão recursiva: $lg n$ no caso de uma
árvore balanceada, mas linear no pior caso de uma árvore
desbalanceada.

\subsubsection{Inserção}

A inserção de elemento na versão imperativa supõe que o elemento a ser
inserido é um novo elemento (não ocorre na árvore). É usado comando de
repetição em vez de recursão, e comando de atribuição é usado para
modificar a árvore na qual o elemento está sendo inserido, em vez de
criar nova árvore.

Um novo nodo é criado com chamada a \ina{novoNodo}, que atribui
referências nulas aos campos \ina{esq} e \ina{dir} e atribui o
argumento ao campo \ina{elem}.

\begin{center}
\begin{tabular}{l}
\begin{alg}{ins}{\decremento}
ins (int k, ArvoreBinariaDeInteiros* arvBin) {
  ArvoreBinariaDeInteiros* nodoCorrente = arvBin
  ArvoreBinariaDeInteiros* prev = NULL
  int v
  while (nodoCorrente != NULL) 
    v = nodoCorrente->elem;
    prev = nodoCorrente;
    if (k < v) 
       nodoCorrente = nodoCorrente -> esq
    else 
       nodoCorrente = nodoCorrente -> dir

  if prev == NULL
    arvBin = novoNodo(k)
  else 
    if (k < prev->elem) 
      prev->esq = novoNodo(k)
    else 
      prev->dir = novoNodo(k)
\end{alg}
\end{tabular}
\end{center}

A complexidade de \ina{ins} é a mesma da versão recursiva: $lg n$ no
caso de uma árvore balanceada, mas linear no pior caso de uma árvore
desbalanceada.

A versão imperativa do algoritmo de remoção de um elemento em uma
árvore binária de pesquisa é deixada como exercício para o leitor
(exercício
\ref{ex:remocao-de-elemento-em-arvore-binaria-de-pesquisa}).

\HRule

%Embora a complexidade da pesquisa a um elemento seja logarítmica no
%caso médio, como vimos no item
%\ref{complexidade-da-pesquisa-binaria-no-pior-caso} acima, no pior
%caso a complexidade da pesquisa é a mesma da complexidade da pesquisa
%sequencial, quando a árvore está totalmente desbalanceada, ficando
%equivalente a uma lista.

Há muitos trabalhos de pesquisa em computação que procuram preservar o
balanceamento de árvores binárias de pesquisa, para manter a
propriedade de complexidade logarítmica para as operações de inserção,
remoção, pesquisa e ordenação de valores, baseados principalmente em
técnicas de transformação: simplificação ou mudança de representação.

A simplificação transforma árvores não balanceadas em árvores
balanceadas (segundo alguma critério de balanceamento) sem adicionar
nenhuma informação adicional a nodos da árvore. A seção
\ref{sec:arvore-AVL} aborda {\em árvores AVL\/}, nas quais a diferença
entre a altura das sub-árvores de qualquer nodo não deve ser maior que
1. A altura de um nodo da árvore é o número de nodos do maior caminho
entre esse nodo e uma folha. A altura de uma árvore é altura do nodo
raiz da árvore.

Outro estrutura de dados que provê balanceamento de árvores de
pesquisa baseada na técnica de transformação por simplificação é a que
vamos chamar de {\em árvores MovPraRaiz\/} (em inglês, {\em splay
  trees\/}), baseada na ideia de mover para raiz um elemento em
operações de inserção, remoção ou pesquisa.  Árvores MovPraRaiz são
abordadas no exercício resolvido \ref{ex:arvores-MovPraRaiz}.

Exemplos de balanceamento via mudança de representação ocorrem com os
seguintes tipos de árvore: {\em árvore bicolor\/} (também chamadas de
vermelha-e-preta ou rubro-negra, em inglês {\em red-black tree\/}) e
{\em árvore B\/} (em inglês, {\em B-tree\/}), abordadas
respectivamente nas seções \ref{sec:arvore-bicolor} e
\ref{sec:arvore-B}.

